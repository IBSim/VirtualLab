import os
import sys
import shutil

import numpy as np

from Scripts.Common.ML import ML, GPR, NN
from Scripts.Common.Optimisation import optimisation
from Scripts.Common.tools.MED4Py import WriteMED
from Scripts.VLPackages.ParaViS import API as ParaViS

dirname = os.path.dirname(os.path.abspath(__file__))
PVFile = '{}/ParaViS.py'.format(dirname)

def AnalysisT_GPR(VL,DataDict):

    Parameters = DataDict['Parameters']
    MLModel = Parameters.MLModel
    model_path = "{}/{}".format(VL.ML.output_dir,MLModel)
    model = GPR.GetModelPCA(model_path) # load GPR model
    _AnalysisTemp(VL,DataDict,model) #perform analysis

def AnalysisT_MLP(VL,DataDict):

    Parameters = DataDict['Parameters']
    MLModel = Parameters.MLModel
    model_path = "{}/{}".format(VL.ML.output_dir,MLModel)
    model = NN.GetModelPCA(model_path) # load MLP model
    _AnalysisTemp(VL,DataDict,model) # perform analysis

def AnalysisVM_GPR(VL,DataDict):

    Parameters = DataDict['Parameters']
    MLModel_T = Parameters.MLModel_T
    MLModel_VM = Parameters.MLModel_VM
    model_T = GPR.GetModelPCA("{}/{}".format(VL.ML.output_dir,MLModel_T)) # load temperature model
    model_VM = GPR.GetModelPCA("{}/{}".format(VL.ML.output_dir,MLModel_VM)) # load VonMises model
    _AnalysisVonMises(VL,DataDict,model_T,model_VM) # peform analysis

def AnalysisVM_MLP(VL,DataDict):

    Parameters = DataDict['Parameters']
    MLModel_T = Parameters.MLModel_T
    MLModel_VM = Parameters.MLModel_VM
    model_T = NN.GetModelPCA("{}/{}".format(VL.ML.output_dir,MLModel_T)) # load temperature model
    model_VM = NN.GetModelPCA("{}/{}".format(VL.ML.output_dir,MLModel_VM)) # load VonMises model
    _AnalysisVonMises(VL,DataDict,model_T,model_VM) # perform analysis

def _AnalysisTemp(VL,DataDict,model):
    '''
    Funciton to perform temperature related analysis
    '''
    Parameters = DataDict['Parameters']
    # copy mesh so results can be added to it
    MeshName = Parameters.MeshName
    resfile_tmp = "{}/compare.med".format(DataDict['TMP_CALC_DIR'])
    meshfile = "{}/{}.med".format(VL.MESH_DIR,MeshName)
    shutil.copy(meshfile,resfile_tmp)
    DesiredTemp = Parameters.DesiredTemp
    GUI = getattr(Parameters,'PVGUI',False)

    # perform 3 pieces of analysis; comparison with simulation and 2 inverse probems
    pv_evals1 = _SimulationCompare(VL,DataDict,model,resfile_tmp,'TemperatureCompare')
    pv_evals2 = _MaxTemp(model, DataDict, resfile_tmp)
    pv_evals3 = _ReachTemp(model, DataDict, resfile_tmp,DesiredTemp)

    # add results to file
    ParaViS.RunEval(PVFile,pv_evals1+pv_evals2+pv_evals3,GUI=GUI)

def _AnalysisVonMises(VL,DataDict,model_t, model_vm):
    '''
    Funciton to perform VonMises related analysis (also uses the temperature model)
    '''
    Parameters = DataDict['Parameters']
    # copy mesh so results can be added to it
    MeshName = Parameters.MeshName
    resfile_tmp = "{}/compare.med".format(DataDict['TMP_CALC_DIR'])
    meshfile = "{}/{}.med".format(VL.MESH_DIR,MeshName)
    shutil.copy(meshfile,resfile_tmp)
    GUI = getattr(Parameters,'PVGUI',False)

    # perform 3 pieces of analysis; comparison with simulation and 2 inverse probems
    pv_evals1 = _SimulationCompare(VL,DataDict,model_vm,resfile_tmp,'VonMisesCompare')
    pv_evals2 = _MaxVM(model_vm,DataDict,resfile_tmp)
    pv_evals3 = _ReachTempMaxVM(model_t,model_vm,DataDict,resfile_tmp)

    # add results to file
    ParaViS.RunEval(PVFile,pv_evals1+pv_evals2+pv_evals3,GUI=GUI)

def _AddResult(ResFile,**kwargs):
    res_obj = WriteMED(ResFile,append=True)
    for ResName,values in kwargs.items():
        res_obj.add_nodal_result(values,ResName)

def _SimulationCompare(VL,DataDict, model,resfile, paravis_funcname):
    '''
    Function to create plots which compare the field generated by the 
    ml model to the simulation.
    '''

    Parameters = DataDict['Parameters']
    TestData = Parameters.TestData
    Index = Parameters.Index

    TestIn, TestOut = ML.VLGetDataML(VL,TestData)

    if type(Index) != list: Index=[Index]

    # get predictions for those specified by Index
    InputIx = TestIn[Index]
    prediction = model.PredictFull(InputIx)

    FieldResults = {}
    for ix,simulation,mlmodel in zip(Index,TestOut[Index],prediction):
        FieldResults['Simulation_{}'.format(ix)] = simulation
        FieldResults['ML_{}'.format(ix)] = mlmodel

    _AddResult(resfile,**FieldResults)

    paravis_evals = []
    for ix in Index:
        arg1 = resfile # path to the med file
        arg2 = ['ML_{}'.format(ix),'Simulation_{}'.format(ix)] # name of the results to compare
        arg3 = ["{}/Ex{}_ML.png".format(DataDict['CALC_DIR'],ix),"{}/Ex{}_Simulation.png".format(DataDict['CALC_DIR'],ix)]
        arg4 = "{}/Ex{}_Error.png".format(DataDict['CALC_DIR'],ix)
        paravis_evals.append([paravis_funcname,(arg1,arg2,arg3,arg4)])

    return paravis_evals

def _MaxField(X,fnc,fnc_args=(),scale=1):
    '''
    Returns the maximum value and gradient from a field of values
    '''
    pred,grad = fnc(X,*fnc_args)
    ix = np.argmax(pred,axis=1)
    _nb = np.arange(0,len(ix))
    return pred[_nb,ix]/scale, grad[_nb,ix]/scale

def _MaxValue(model,scale=1):
    '''
    Identify inputs which will deliver the maximum possible value in the field
    '''
    bounds = [[0,1]]*model.Dataspace.NbInput
    fnc = model.GradientFull
    fnc_args = [False] # arguments for model.GradientFull (inputs are assumed to be in [0,1])
    _fnc_args = [fnc,fnc_args,scale] # the arguments passed to _MaxField

    cd_scale,val = optimisation.GetOptima(_MaxField,50,bounds,fnc_args=_fnc_args,seed=100)
    cd = model.RescaleInput(cd_scale)

    return cd, val

def _ReachMaxValue(model,max_temp,bounds=None,NbInit=10,seed=123):
    '''
    Identify inputs which will deliver a certain maximum temperature in the field
    '''
    bounds = [[0,1]]*model.Dataspace.NbInput
    fnc = model.GradientFull
    fnc_args = [False] # arguments for model.GradientFull (inputs are assumed to be in [0,1])
    _fnc_args = [fnc,fnc_args] # the arguments passed to _MaxField

    cd_scale, val, val_lse = optimisation.GetOptimaLSE(_MaxField, max_temp, NbInit, bounds,
                             seed=seed, fnc_args=_fnc_args)
    cd = model.RescaleInput(cd_scale)
    return cd, val, val_lse

def _ReachMaxValueConstraint(model_t, model_vm, max_temp,bounds=None,NbInit=10,seed=123):
    '''
    Identify inputs which will deliver a certain maximum temperature while maximising the VonMises stress
    '''
    bounds = [[0,1]]*model_vm.Dataspace.NbInput

    func_con = model_t.GradientFull
    func_con_args = [False] # arguments for model.GradientFull (inputs are assumed to be in [0,1])
    _func_con_args = [func_con,func_con_args]
    constraint_dict = optimisation.FixedBound(max_temp,_MaxField,_func_con_args)

    func = model_vm.GradientFull
    func_args = [False] # arguments for model.GradientFull (inputs are assumed to be in [0,1])
    _func_args = [func,func_args]

    cd_scale, val = optimisation.GetOptima(_MaxField,NbInit,bounds,fnc_args=_func_args,seed=seed,constraints=constraint_dict)
    cd = model_vm.RescaleInput(cd_scale) #  can use either model_t or model_vm

    return cd, val

def _MaxTemp(model,DataDict, resfile):
    '''
    Identify the inputs which will deliver the maximum possible temperature
    '''
    cd, val = _MaxValue(model)
    best_cd,best_val = cd[0], val[0]
    best_cd_str = ", ".join(["{:.2e}".format(v) for v in best_cd])

    print('###############################################\n')
    print('Parameter combination which will deliver a maximum temperature of {:.2f} C:\n'.format(best_val))
    print(best_cd_str)
    print('\n###############################################\n')

    prediction = model.PredictFull(best_cd)

    _AddResult(resfile,MaxTemperature=prediction.flatten())

    paravis_funcname = 'CaptureTemperature'
    arg1 = resfile # path to the med file
    arg2 = 'MaxTemperature'
    arg3 = '{}/MaxTemperature.png'.format(DataDict['CALC_DIR'])

    return [[paravis_funcname,[arg1,arg2,arg3]]]

    
def _ReachTemp(model,DataDict,resfile,DesiredTemp):
    '''
    Identify the inputs which will deliver the temperature specified by DesiredTemp
    '''

    cd,val,val_lse = _ReachMaxValue(model,DesiredTemp)

    print('###############################################\n')
    print('Different parameter combinations which will deliver {:.2f} C:\n'.format(DesiredTemp))
    for _cd in cd[:5]:
        best_cd_str = ", ".join(["{:.2e}".format(v) for v in _cd])
        print(best_cd_str)
    print('\n###############################################\n')

    prediction = model.PredictFull(cd[:5])

    resnames,image_paths = [],[]
    for i, val in enumerate(prediction):
        name = 'T{}_{}'.format(DesiredTemp,i+1)
        _AddResult(resfile,**{name:val})
        resnames.append(name)
        image_paths.append("{}/{}.png".format(DataDict['CALC_DIR'],name))

    return [['CaptureTemperature',[resfile,resnames,image_paths]]]

    

def _MaxVM(model,DataDict,resfile):
    '''
    Identify the inputs which will deliver the maximum possible VonMises stress
    '''
    cd, val = _MaxValue(model)
    best_cd,best_val = cd[0], val[0]
    best_cd_str = ", ".join(["{:.2e}".format(v) for v in best_cd])

    print('###############################################\n')
    print('Parameter combination which will deliver a maximum Von Mises stress of {:.2f} MPa:\n'.format(best_val))
    print(best_cd_str)
    print('\n###############################################\n')

    prediction = model.PredictFull(best_cd)

    _AddResult(resfile,MaxVonMises=prediction.flatten())

    paravis_funcname = 'CaptureVonMises'
    arg1 = resfile # path to the med file
    arg2 = 'MaxVonMises'
    arg3 = '{}/MaxVonMises.png'.format(DataDict['CALC_DIR'])

    return [[paravis_funcname,[arg1,arg2,arg3]]]

def _ReachTempMaxVM(model_t,model_vm,DataDict,resfile):
    '''
    Identify the inputs which will deliver the maximum VonMises stress 
    for a maximum temperature specified by DesiredTemp
    '''

    DesiredTemp = 600
    cd,val= _ReachMaxValueConstraint(model_t,model_vm,DesiredTemp)
    best_cd,best_val = cd[0],val[0]
    best_cd_str = ", ".join(["{:.2e}".format(v) for v in best_cd])
    print('###############################################\n')
    print('Parameter combination which delivers {:.2f} C and maximises the Von Mises stress, delivering {:.2f} MPa:\n'.format(DesiredTemp,best_val))
    print(best_cd_str)
    print('\n###############################################\n')

    prediction_vm = model_vm.PredictFull(best_cd)
    prediction_t = model_t.PredictFull(best_cd)

    name = 'T{}'.format(DesiredTemp)

    _AddResult(resfile,**{"{}_VM".format(name):prediction_vm.flatten(),"{}_T".format(name):prediction_t.flatten()})

    pv_evals = [['CaptureVonMises',[resfile,"{}_VM".format(name),'{}/{}_VM.png'.format(DataDict['CALC_DIR'],name)]],
                ['CaptureTemperature',[resfile,"{}_T".format(name),'{}/{}_T.png'.format(DataDict['CALC_DIR'],name)]]

                ]

    return pv_evals


