import os
import sys
import shutil
sys.dont_write_bytecode=True

import numpy as np
import h5py
import matplotlib.pyplot as plt
from bisect import bisect_left as bl
from sklearn.cluster import KMeans

from Scripts.Common.tools import MEDtools
from Scripts.VLPackages.Salome.API import Run as SalomeRun
from Scripts.VLPackages.ERMES.API import Run as ERMESRun

def ERMES_Mesh(VL, MeshIn, MeshOut, Parameters, tempdir='/tmp', AddPath=[], LogFile=None):
    '''
    MeshIn is used to build a conformal mesh (MeshOut) which is used by ERMES
    to generate the EM loads. A coil is added above the sample along with a
    vacuum which sits around both.
    '''

    script = "{}/EM/NewEM.py".format(VL.SIM_SCRIPTS)
    EM_GUI = getattr(Parameters,'EM_GUI',False)
    DataDict = {'Parameters':Parameters,'InputFile':MeshIn,'OutputFile':MeshOut}
    err = SalomeRun(script, DataDict=DataDict, AddPath=AddPath,
                    OutFile=LogFile, tempdir=tempdir, GUI=EM_GUI)
    return err

def ERMES_Conversion(ERMESResFile,ResFile_MED):
    '''
    Takes the .post.res file generated by ERMES and writes in an rmed format
    which can be opened by ParaVis.
    Check flag verifies that additional information generated by ERMES is correct
    '''
    ERMESMesh = MEDtools.MeshInfo(ResFile_MED)
    ERMESNbNodes = ERMESMesh.NbNodes
    ERMESMesh.Close()

    # append results to ERMESResFile
    ERMESrmed = h5py.File(ResFile_MED, 'a')
    # Some groups require specific formatting so take an empty group from format file
    Formats = h5py.File("{}/MED_Format.med".format(os.path.dirname(MEDtools.__file__)),'r')
    GrpFormat = Formats['ELEME']

    # Take results from .post.res results file and create .rmed file to view in ParaVis
    # Todo -  a more efficient way of doign this without dictionary
    ResNames = []
    Start, End = -1,-2
    with open(ERMESResFile,'r') as f:
        for j,line in enumerate(f):
            split = line.split()
            if split[0] == 'Result':
                ResName= (split[1])[1:-1]
                Start = j+2
                End = j+1+ERMESNbNodes
                Result = []
                ResNames.append(ResName)
                continue

            if Start <= j <= End:
                Result.append(list(map(float,split[1:])))
            elif j == End+1:
                Result = np.array(Result)
                ERMESrmed.copy(GrpFormat,"CHA/{}".format(ResName))
                grp = ERMESrmed["CHA/{}".format(ResName)]
                grp.attrs.create('MAI',ERMESMesh.MeshName,dtype='S{}'.format(len(ERMESMesh.MeshName)))
                if Result.shape[1] == 1: NOM =  'Res'.ljust(16)
                elif Result.shape[1] == 3: NOM = 'DX'.ljust(16) + 'DY'.ljust(16) + 'DZ'.ljust(16)
                grp.attrs.create('NCO',Result.shape[1],dtype='i4')
                grp.attrs.create('NOM', NOM,dtype='S100')
                grp.attrs.create('TYP',6,dtype='i4')
                grp.attrs.create('UNI',''.ljust(len(NOM)),dtype='S100')
                grp.attrs.create('UNT','',dtype='S1')

                grp = grp.create_group('0000000000000000000100000000000000000001')
                grp.attrs.create('NDT',1,dtype='i4')
                grp.attrs.create('NOR',1,dtype='i4')
                grp.attrs.create('PDT',0.0,dtype='f8')
                grp.attrs.create('RDT',-1,dtype='i4')
                grp.attrs.create('ROR',-1,dtype='i4')
                grp = grp.create_group('NOE')
                grp.attrs.create('GAU','',dtype='S1')
                grp.attrs.create('PFL','MED_NO_PROFILE_INTERNAL',dtype='S100')
                grp = grp.create_group('MED_NO_PROFILE_INTERNAL')
                grp.attrs.create('GAU','',dtype='S1'    )
                grp.attrs.create('NBR', ERMESMesh.NbNodes, dtype='i4')
                grp.attrs.create('NGA',1,dtype='i4')
                grp.create_dataset("CO",data=Result.flatten(order='F'))

    ERMESrmed.close()
    Formats.close()

    return ResNames

def Prep(ERMESMeshFile,tmpERMESdir):
    # Get mesh info using the MeshInfo class written using h5py
    ERMESMesh = MEDtools.MeshInfo(ERMESMeshFile)
    contacts = True

    # Define duplicate nodes for contact surfaces, which is on the SampleSurface and CoilSurface
    if contacts:
        CoilSurface = ERMESMesh.GroupInfo('CoilSurface')
        SampleSurface = ERMESMesh.GroupInfo('SampleSurface')

        ContactNodes = SampleSurface.Nodes.tolist() + CoilSurface.Nodes.tolist()
        ContactNodeSt = ERMESMesh.NbNodes + 1

    # ==========================================================================
    # Node information
    print('Nodes')
    NodeList = list(range(1,ERMESMesh.NbNodes + 1)) 
    if contacts: NodeList += ContactNodes
    Coords = ERMESMesh.GetNodeXYZ(NodeList)
    strNodes = ["No[{}] = p({:.10f},{:.10f},{:.10f});\n".format(i+1,Crd[0],Crd[1],Crd[2]) for i,Crd in enumerate(Coords)]
    strNodes.insert(0,"// List of nodes\n")
    strNodes = "".join(strNodes)

    with open('{}/Nodes.dat'.format(tmpERMESdir),'w+') as f:
        f.write(strNodes)

    # ==========================================================================
    # Element info
    if contacts:
        print('Contacts')
        Vacuumgrp = ERMESMesh.GroupInfo('Vacuum')
        VacuumNew = np.copy(Vacuumgrp.Connect)
        ContactFaceOrig = np.vstack((SampleSurface.Connect,CoilSurface.Connect))
        ContactFaceNew = np.copy(ContactFaceOrig)
        for i, nd in enumerate(ContactNodes):
            NewNode = ContactNodeSt+i
            VacuumNew[VacuumNew == nd] = NewNode
            ContactFaceNew[ContactFaceNew == nd] = NewNode

    print('Elements')
    # Desribes the connectivity of the mesh. Same for Electrostatic and FullWave
    strMesh = ["// Volume elements\n"]
    EMlist = ['Vacuum','Coil'] + ['Pipe','Block','Tile']
    for i,name in enumerate(EMlist):
        if contacts and i==0: GrpCnct = VacuumNew
        else: GrpCnct = ERMESMesh.GroupInfo(name).Connect
        for Nodes in GrpCnct:
            strMesh.append("VE({},{},{},{},{});\n".format(Nodes[2],Nodes[1],Nodes[0],Nodes[3],i+1))
    strMesh = "".join(strMesh)

    with open('{}/Elements.dat'.format(tmpERMESdir),'w+') as f:
        f.write(strMesh)

    strContact = ["// Contact elements\n"]
    if contacts:
        for OrigNd, NewNd in zip(ContactFaceOrig,ContactFaceNew):
            strContact.append("CE = n([{},{},{},{},{},{}]);\n".format(OrigNd[2],OrigNd[1],OrigNd[0],NewNd[2],NewNd[1],NewNd[0]))
    strContact = "".join(strContact)

    with open('{}/Contacts.dat'.format(tmpERMESdir),'w+') as f:
        f.write(strContact)


    ERMESMesh.Close()

def Static(Parameters,ERMESMeshFile,tmpERMESdir):

    analysis_name = '{}/Static'.format(tmpERMESdir)

    ERMESMesh = MEDtools.MeshInfo(ERMESMeshFile)

    # req: Frequency, materials
    # opt: NbProc
    # look to add in stuff about convergence accuracy etc.

    # ==========================================================================
    # File 'Static'

    # Define problem type
    Stat01 = "// Setting problem\n" + \
    "ProblemType = Static;\n" + \
    "ProblemType = GiDTol9;\n" + \
    "ProblemType = RELSSOL;\n" + \
    "ProblemType = 1st;\n" + \
    "ProblemType = GAv;\n" + \
    "ProblemType = NRFIG;\n" + \
    "ProblemType = FSWRIF;\n" + \
    "ProblemType = OFFASCII;\n" + \
    "ProblemType = IMPJOFF;\n" + \
    "ProblemType = {}pr;\n".format(getattr(Parameters,'NbProc',1)) + \
    "ProblemType = LE;\n" + \
    "ProblemFrequency = {};\n".format(Parameters.Frequency*2*np.pi) + \
    "ProblemType = CheckConsistency;\n"

    # Define Material properties. Only need Electrical Conductivity of 1 for coil
    # for this analysis.
    EMlist = ['Vacuum','Coil'] + sorted(Parameters.Materials.keys())
    Electrolist = [0]*len(EMlist)
    Electrolist[1] = 1
    StatMat = "// Material properties\n"
    for i,res in enumerate(Electrolist):
        StatMat += "PROPERTIES[{}].IHL_ELECTRIC_CONDUCTIVITY  = {};\n".format(i+1,res) + \
        "PROPERTIES[{}].REAL_MAGNETIC_PERMEABILITY = {};\n".format(i+1,1) + \
        "PROPERTIES[{}].IMAG_MAGNETIC_PERMEABILITY = {};\n".format(i+1,0) + \
        "PROPERTIES[{}].REAL_ELECTRIC_PERMITTIVITY = {};\n".format(i+1,1) + \
        "PROPERTIES[{}].IMAG_ELECTRIC_PERMITTIVITY = {};\n".format(i+1,0)

    # Property used for CoilIn BC (100 is a nominal amount)
    StatMat += "// Special materials properties\n" + \
    "PROPERTIES[17].COMPLEX_IBC = [0.0,100.0];\n"

    # BC at CoilOut terminal
    StatBC =["No[{}].V.Fix(0.0);\n".format(nd) for nd in ERMESMesh.GroupInfo('CoilOut').Nodes]
    StatBC.insert(0,"// Fixing static voltage on nodes in nodes\n")
    StatBC = "".join(StatBC)

    # describes the building procedure for the problem
    Stat05 = "// Initializing building \n" + \
    "ElementsGroup = electromagnetic_group;\n\n" + \
    '// Generating debug results (if "Debug" mode activated) \n\n' + \
    "// Building and solving\n" + \
    "ProblemType = Build;\n"

    with open('{}/Nodes.dat'.format(tmpERMESdir),'r') as f:
        strNodes = f.read()
    with open('{}.dat'.format(analysis_name),'w+') as f:
        f.write(Stat01 + strNodes + StatMat + StatBC + Stat05)


    # ==========================================================================
    # File 'Static-1'
    shutil.copy2('{}/Elements.dat'.format(tmpERMESdir),'{}-1.dat'.format(analysis_name))

    # ==========================================================================
    # File 'Static-2'
    CoilInCnct = ERMESMesh.GroupInfo('CoilIn').Connect
    StatBC = ["GRC({},{},{},17);\n".format(Nodes[0],Nodes[1],Nodes[2]) for Nodes in CoilInCnct]
    StatBC.insert(0, "// Static Robin elements\n")
    StatBC = "".join(StatBC)
    with open('{}-2.dat'.format(analysis_name),'w+') as f:
        f.write(StatBC)

    # ==========================================================================
    # File 'Static-5'
    Stat51 = "// Static solver\n" + \
    "LinearSolver Diagonal = Bi_Conjugate_Gradient(1000000,250,0.000000001000000);\n\n" + \
    "// Solving static problem\n" + \
    "ElectromagneticStrategy.Solve(electromagnetic_group);\n\n" + \
    "// Setting output files\n" + \
    "ProblemType = PrintHOMesh;\n\n"  + \
    "// Computing and printing J current density\n" + \
    "ProblemType = Show_J_Static_smoothed;\n\n" + \
    "// Export currents to file\n" + \
    "ProblemType = Export_Static_Currents;\n\n"

    Stat52 = "// Print the results of the field integrals\n" + \
    "ProblemType = Project_Static_Fields;\n"

    with open('{}-5.dat'.format(analysis_name),'w+') as f:
        f.write(Stat51 + Stat52)

    # ==========================================================================
    # File 'Static-9'
    # Output file where currents calculated in the electrostatic simulation is saved to
    name = '1'
    with open('{}-9.dat'.format(analysis_name),'w+') as f:
        f.write('{}'.format(name))

    ERMESMesh.Close()

    return analysis_name

def Wave(VL,Parameters,ERMESMeshFile,tmpERMESdir,ref_temp = 20, check=False):
    ERMESMesh = MEDtools.MeshInfo(ERMESMeshFile)

    analysis_name = '{}/Wave{}'.format(tmpERMESdir,ref_temp)


    # req: Frequency, materials
    # opt: NbProc
    # look to add in stuff about convergence accuracy etc.

    # ==========================================================================
    # File 'Wave'

    Wave01 = "// Setting problem\n" + \
    "ProblemType = E3D;\n" + \
    "ProblemType = GiDTol9;\n" + \
    "ProblemType = RELSSOL;\n" + \
    "ProblemType = 1st;\n" + \
    "ProblemType = GAv;\n" + \
    "ProblemType = NRFIG;\n" + \
    "ProblemType = FSWRIF;\n" + \
    "ProblemType = OFFASCII;\n" + \
    "ProblemType = IMPJON;\n" + \
    "ProblemType = {}pr;\n".format(getattr(Parameters,'NbProc',1)) + \
    "ProblemType = LE;\n" + \
    "ProblemFrequency = {};\n".format(Parameters.Frequency*2*np.pi) + \
    "ProblemType = CheckConsistency;\n"

    WaveBC = ["// Creating High order nodes\n","ProblemType = CreateHONodes;\n","// Making contact elements\n", \
        "ProblemType = MakeContact;\n","// Fixing degrees of freedom in PEC nodes\n" ]
    PECEls = ERMESMesh.GroupInfo('VacuumSurface').Connect
    WaveBC += ["PEC = n([{},{},{}]);\n".format(Nodes[0],Nodes[1],Nodes[2]) for Nodes in PECEls]
    WaveBC = "".join(WaveBC)

    Wave05 = "// Initializing building \n" + \
        "ElementsGroup = electromagnetic_group;\n\n" + \
        '// Generating debug results (if "Debug" mode activated) \n\n' + \
        "// Building and solving\n" + \
        "ProblemType = Build;\n"

    WaveMat = "// Material properties\n"
    EMlist = ['Vacuum','Coil'] + ['Pipe','Block','Tile']
    for i, part in enumerate(EMlist):
        MgPrm, ElPrm = [1,0], [1,0]
        if part in ('Vacuum','Coil'):
            ElCnd = 0
        else :
            fpath = '{}/{}/{}.dat'.format(VL.MATERIAL_DIR,Parameters.Materials[part],'ElecCond')
            prop = np.fromfile(fpath,dtype=float,count=-1,sep=" ")
            ElCnd = np.interp(ref_temp,prop[::2],prop[1::2])

        WaveMat += "PROPERTIES[{}].IHL_ELECTRIC_CONDUCTIVITY  = {};\n".format(i+1,ElCnd) + \
        "PROPERTIES[{}].REAL_MAGNETIC_PERMEABILITY = {};\n".format(i+1,MgPrm[0]) + \
        "PROPERTIES[{}].IMAG_MAGNETIC_PERMEABILITY = {};\n".format(i+1,MgPrm[1]) + \
        "PROPERTIES[{}].REAL_ELECTRIC_PERMITTIVITY = {};\n".format(i+1,ElPrm[0]) + \
        "PROPERTIES[{}].IMAG_ELECTRIC_PERMITTIVITY = {};\n".format(i+1,ElPrm[1])
    WaveMat += "// Special materials properties\n" + \
    "PROPERTIES[32].COMPLEX_IBC = [1.0,0.0];\n"

    with open('{}/Nodes.dat'.format(tmpERMESdir),'r') as f:
        strNodes = f.read()
    with open('{}.dat'.format(analysis_name),'w+') as f:
        f.write(Wave01 + strNodes + WaveMat + WaveBC + Wave05)

    # ==========================================================================
    # File 'Wave-1'
    shutil.copy2('{}/Elements.dat'.format(tmpERMESdir),'{}-1.dat'.format(analysis_name))

    # ==========================================================================
    # File 'Wave-2'
    # Need blank file for Wave analysis to execute properly
    with open('{}-2.dat'.format(analysis_name),'w+') as f:
        f.write("// Source elements\n")

    # ==========================================================================
    # File 'Wave-3'
    shutil.copy2('{}/Contacts.dat'.format(tmpERMESdir),'{}-3.dat'.format(analysis_name))

    # ==========================================================================
    # File 'Wave-5'

    Wave51 = "// Complex solver\n" + \
    "LinearSolver Diagonal = Bi_Conjugate_Gradient(1000000,250,0.000000001000000);\n\n" + \
    "// Solving\n" + \
    "ElectromagneticStrategy.Solve(electromagnetic_group);\n\n" + \
    "// Main results (E field)\n" + \
    "CalculateNodal(IMAG_E);\n" + \
    "CalculateNodal(REAL_E);\n" + \
    "CalculateNodal(MOD_E);\n\n" + \
    "// Derivatives (H field)\n" + \
    "ProblemType = CalculateH;\n" + \
    "CalculateNodal(IMAG_H);\n" + \
    "CalculateNodal(REAL_H);\n" + \
    "CalculateNodal(MOD_H);\n\n" + \
    "// J currents\n" + \
    "ProblemType = CalculateJ;\n\n"

    Wave52 = "// Projecting modes in port planes\n" + \
    "ProblemType = Project;\n\n" + \
    "// Printing new high order mesh\n" + \
    "ProblemType = PrintHOMesh;\n\n" + \
    "// Other results\n" + \
    "ProblemType = CalculateJouleHeating;\n" + \
    "// J currents\n" + \
    "Print(REAL_J);\n" + \
    "Print(IMAG_J);\n" + \
    "Print(MOD_J);\n" + \
    "// Printing main results (E field)\n" +\
    "Print(IMAG_E);\n" + \
    "Print(REAL_E);\n" + \
    "Print(MOD_E);\n\n"

    # if check is True then this is included to calculate the current in the
    # CoilIn terminal. This can then be verified against the answer calculated
    # from the results
    if check:
        if True:
            sample = ERMESMesh.GroupInfo('Sample')
            strSample = ["PVIE({},{},{},{},32);\n".format(*FNodes) for FNodes in sample.Connect]
            strSample.insert(0,"// // Field integration over a volume \n")
            strSample = "".join(strSample)
        else: strSample=""

        CoilInCnct = ERMESMesh.GroupInfo('CoilIn').Connect
        strFace = ["PSIE({},{},{},32);\n".format(FNodes[0],FNodes[1],FNodes[2]) for FNodes in CoilInCnct]
        strFace.insert(0,"// Field integration over a surface\n")
        strFace = "".join(strFace)

        strSample = strSample + "\n" + strFace

    else : strSample = ""

    with open('{}-5.dat'.format(analysis_name),'w+') as f:
        f.write(Wave51 + strSample + Wave52)

    ERMESMesh.Close()

    return analysis_name

def CalculateCurrent(ERMESResFile,resname='Current_density_smoothed'):
    ''' Calculate current travelling through the coil at the input terminal'''

    # Get the results array for current
    CurrentRes_XYZ = MEDtools.NodalResult(ERMESResFile, resname)
    # get magnitude of the current
    CurrentRes = np.linalg.norm(CurrentRes_XYZ,axis=1)

    # Get mesh connectivity at the terminal
    ERMESMesh = MEDtools.MeshInfo(ERMESResFile)
    CoilInCnct = ERMESMesh.GroupInfo('CoilIn').Connect
    CoilInArea, CoilInCurr, CoilInCurrsq = 0, 0, 0
    for nodes in CoilInCnct:
        coor1, coor2, coor3 = ERMESMesh.GetNodeXYZ(nodes)
        J1, J2, J3 = CurrentRes[nodes - 1]

        area = 0.5*np.linalg.norm(np.cross(coor2-coor1,coor3-coor1))
        CoilInArea += area
        CoilInCurr += area*(J1 + J2 + J3)/3
        CoilInCurrsq += area*(J1**2 + J2**2 + J3**2)/3

    ERMESMesh.Close()

    return CoilInArea, CoilInCurr, CoilInCurrsq

def CalculateVolume(ERMESResFile):
    ERMESMesh = MEDtools.MeshInfo(ERMESResFile)
    Coor = ERMESMesh.GetNodeXYZ(list(range(1,ERMESMesh.NbNodes+1)))
    Sample = ERMESMesh.GroupInfo('Sample')
    Volumes = []
    for Nds in  Sample.Connect:
        v1,v2,v3,v4 = Coor[Nds-1]
        vol = 1/float(6)*abs(np.dot(np.cross(v2-v1,v3-v1),v4-v1))
        Volumes.append(vol)
    ERMESMesh.Close()
    return np.array(Volumes)

def CellAverage(ERMESResFile,ResName):
    # Get the results array
    Result = MEDtools.NodalResult(ERMESResFile, ResName)

    # Calculate result averaged over cell
    ERMESMesh = MEDtools.MeshInfo(ERMESResFile)
    Sample = ERMESMesh.GroupInfo('Sample')
    ERMESMesh.Close()
    # average out
    Res_vol = [np.sum(Result[Nds-1])/4 for Nds in Sample.Connect]
    return np.array(Res_vol)

def ScaleResults(ERMESResFile,factor_dict):
    for ResName,factor in factor_dict.items():
        g = h5py.File(ERMESResFile, 'a')
        gRes = g['/CHA/{}'.format(ResName)]
        step = list(gRes.keys())[0]
        gRes = gRes['{}/NOE/MED_NO_PROFILE_INTERNAL'.format(step)]
        Result = gRes['CO'][:]
        gRes['CO'][...] = Result*factor
        a = gRes['CO'][...]

def Thresholding(JH_Vol,Volumes,threshold=1):
    if threshold>=1: return JH_Vol

    JH_Vol_threshold = np.zeros(JH_Vol.shape)
    # ==========================================================================
    # sort JH_Vol in descending order
    JH_Vol,Volumes = np.array(JH_Vol),np.array(Volumes)
    sortlist = np.argsort(JH_Vol)[::-1]
    JH_Vol, Volumes = JH_Vol[sortlist], Volumes[sortlist]

    # ==========================================================================
    # Find position in the cululative sum of watts where the threshold value is been reached
    Watts = JH_Vol*Volumes
    Watts_sum = Watts.sum()
    CumSum = Watts.cumsum()/Watts_sum # cumulative sum scaled to 1
    ix = bl(CumSum,threshold) #index where threshold is reached
    # fill entries of JH_Vol_threshold with values that are being kept
    JH_Vol, keep_ix = JH_Vol[:ix+1], sortlist[:ix+1]
    JH_Vol_threshold[keep_ix] = JH_Vol

    return JH_Vol_threshold

def Clustering(JH_Vol,nb_cluster,n_init=3,seed=123):
    state = np.random.get_state() # get current random state
    np.random.seed(seed) # set random state to seed value for reproducability
    if nb_cluster>=JH_Vol.shape[0]: return JH_Vol, 1

    JH_Vol_cluster = np.zeros(JH_Vol.shape)
    # ==========================================================================
    # cluster JH_Vol in to nb_cluster groups
    X = JH_Vol.reshape(-1,1)
    X_sc = (X - X.min())/(X.max()-X.min()) # scale to [0,1] range
    kmeans = KMeans(n_clusters=nb_cluster,n_init=n_init,n_jobs=1).fit(X_sc)

    # ==========================================================================
    # calculate goodness of fit
    SDAM = ((X_sc - X_sc.mean())**2).sum() # Squared deviation for mean array
    SDCM = kmeans.inertia_ # Squared deviation class mean
    GFV = (SDAM-SDCM)/SDAM # Goodness of fit value

    # ==========================================================================
    # rescale JH_vol to original range. this will have nb_cluster entries
    cluster_centres = kmeans.cluster_centers_*(X.max()-X.min()) + X.min() # len is nb_clusters
    for i,cluster_val in enumerate(cluster_centres):
        JH_Vol_cluster[kmeans.labels_==i] = cluster_val

    np.random.set_state(state)

    return JH_Vol_cluster, GFV

def GFV(original,clustered):
    SDAM = ((original - original.mean())**2).sum()
    SDCM = ((original - clustered)**2).sum()
    return 1 - SDCM/SDAM


def SampleElement(MeshFile):
    ERMESMesh = MEDtools.MeshInfo(MeshFile)
    Elements = ERMESMesh.GroupInfo('Sample').Elements
    ERMESMesh.Close()
    return Elements

def ERMES2CA(ResFile,threshold=1,nb_clusters=500, scale=True):
    ''' Function which takes ERMES output and makes it applicable to CodeAster.
        This requires  compressing the data as it is too time consuming to assign
        a group to each element.'''
    # ==========================================================================
    # get necessary info
    Volumes = CalculateVolume(ResFile)
    JH_Vol = CellAverage(ResFile,'Joule_heating')
    power = (Volumes*JH_Vol).sum()

    # ==========================================================================
    # perform thresholding (generally poor performance)
    JH_Vol = Thresholding(JH_Vol,Volumes,threshold)
    if threshold<1:
        nb = (JH_Vol>0).sum()
        print("The {} most influential elements will be assigned EM loads ({}% threshold)".format(nb, threshold*100))
    # ==========================================================================
    # perform clustering (very good performance)
    JH_Vol, GFV = Clustering(JH_Vol,nb_clusters)
    if nb_clusters<JH_Vol.shape[0]:
        print("The {} elements are clustered in to {} groups.\n"\
              "Goodness of Fit Value: {}".format(JH_Vol.shape[0],nb_clusters,GFV))

    # ==========================================================================
    # optionally scale results so that the anticipated power is delivered
    if scale:
        power_new = (Volumes*JH_Vol).sum()
        JH_Vol = JH_Vol*power/power_new

    return JH_Vol


def CreateEMGroups(mesh_in,mesh_out,JH_Vol,group_vals,grouping='h5py'):

    # ==========================================================================
    # Make dictionary of group names and elements
    Elements = SampleElement(mesh_in)
    GroupDict = {}
    for i, val in enumerate(group_vals):
        GroupDict['_{}'.format(i)] = Elements[JH_Vol==val]

    if grouping.lower()=='h5py':
        # copy mesh file
        shutil.copy2(mesh_in,mesh_out)
        AddGroups(mesh_out,GroupDict)



def AddGroups(MeshFile, GroupDict):

    # ==========================================================================
    # Open MeshFile using h5py to append groups to
    MeshMed = h5py.File(MeshFile,'a')
    ElInfo = MeshMed["ENS_MAA/Sample/-0000000000000000001-0000000000000000001/MAI/TE4"]
    ElList = ElInfo["NUM"][:] # number for each element
    ElFam = ElInfo["FAM"][:] # group number associated with each element
    # Elbool = np.searchsorted(ElList,Elements)
    # ElList = ElList[Elbool]
    # ElFam = ElFam[Elbool]

    # ==========================================================================
    # Get group numbers already associated with mesh
    ElGrps = MeshMed["FAS/Sample/ELEME"]
    MinNum, GrpName = 0, {}
    for grpname in ElGrps.keys():
        grpnum = ElGrps[grpname].attrs['NUM']
        MinNum = min(MinNum,grpnum) # element groups are negative numbers
        if grpnum in ElFam:
            GrpName[grpnum] = ElGrps[grpname]
    NewNum = MinNum-1 # Number which groping will start at

    # ==========================================================================
    # Formats file contains format needed to add group
    Formats = h5py.File("{}/MED_Format.med".format(os.path.dirname(MEDtools.__file__)),'r')

    for grp_name,els in GroupDict.items():
        # get the indicides and group numbers associated with the elements in each group
        ElIxcl = np.searchsorted(ElList,els)
        ElFamcl = ElFam[ElIxcl]

        for fam in np.unique(ElFamcl):
            NameGrps = GrpName[fam]['GRO/NOM'][:] # group names already associated with this family id
            EMnames = MEDtools.ASCIIname([grp_name]) # ASCII name for new group
            NumGrps = NameGrps.shape[0]+1
            dsetFormat = Formats["Name{}".format(NumGrps)] # copy group format from Formats

            # Create new group containing relevant information
            h5grp = "Grp{}".format(NewNum)
            ElGrps.copy(dsetFormat,"{}/GRO/NOM".format(h5grp))
            ElGrps[h5grp].attrs.create('NUM',NewNum,dtype='i4')
            ElGrps["{}/GRO".format(h5grp)].attrs.create('NBR',NumGrps,dtype='i4')
            ElGrps["{}/GRO/NOM".format(h5grp)][:] = np.vstack((NameGrps,EMnames))

            # Update ElFam with new family IDs created
            IxChange = ElIxcl[ElFamcl==fam]
            ElFam[IxChange] = NewNum

            NewNum -=1

    Formats.close()

    ElInfo["FAM"][:] = ElFam
    MeshMed.close()



def ERMES_linear(VL,SimDict):
    Parameters = SimDict['Parameters']

    # temp folder for ERMES files
    ERMESdir = "{}/ERMES".format(SimDict['TMP_CALC_DIR'])
    os.makedirs(ERMESdir)
    #==========================================================================
    # Create Mesh
    ERMESMeshFile = "{}/Mesh.med".format(ERMESdir)

    err = ERMES_Mesh(VL, SimDict['MeshFile'], ERMESMeshFile, Parameters,
                     tempdir=ERMESdir, AddPath=[VL.SIM_SCRIPTS])
    if err: return sys.exit('Issue creating mesh')


    # ==========================================================================
    # get mesh information in to ermes format
    print('Prep')
    Prep(ERMESMeshFile,ERMESdir)

    # ==========================================================================
    # Create static files & run
    # the static analysis gives the current density in the coil
    print('Static')
    static_name = Static(Parameters,ERMESMeshFile,ERMESdir)
    err = ERMESRun(static_name)
    static_resfile = "{}.post.res".format(static_name)
    static_res = ERMES_Conversion(static_resfile, ERMESMeshFile)

    # calculate the current at the input terminal
    area,coil_current,coil_currentsq = CalculateCurrent(ERMESMeshFile)

    # scale resulting currents to ensure a current of 1 is recorded at input temrinal
    scale_factor = 1/coil_current

    JSource = np.loadtxt("{}/Exp_J_Sources/ExpJSource-1.dat".format(ERMESdir),skiprows=1)
    sourcestring = '0\n'
    for source in JSource:
        elems = "{}  {}  {}  {}  ".format(*source[:4].astype('int'))
        vals = "{:.4f}  {:.4f}  {:.4f}\n".format(*source[4:]*scale_factor)
        newstr = elems+vals
        sourcestring+=newstr

    with open("{}/Exp_J_Sources/ExpJSource-1.dat".format(ERMESdir),'w+') as f:
        f.write(sourcestring)

    # ==========================================================================
    # Create wave files & run
    print('Wave')
    wave_name = Wave(VL,Parameters,ERMESMeshFile,ERMESdir)
    err = ERMESRun(wave_name)
    wave_resfile = "{}.post.res".format(wave_name)
    wave_res = ERMES_Conversion(wave_resfile, ERMESMeshFile)

    # ==========================================================================
    # Copy files
    shutil.copy2("{}/ERMESLog".format(ERMESdir), os.path.dirname(SimDict['ERMES_ResFile']))
    shutil.copy2(ERMESMeshFile,SimDict['ERMES_ResFile'])

def ERMES_linear_wmesh(VL,SimDict):
    Parameters = SimDict['Parameters']

    # temp folder for ERMES files
    ERMESdir = "{}/ERMES".format(SimDict['TMP_CALC_DIR'])
    os.makedirs(ERMESdir)
    #==========================================================================
    # Create Mesh
    ERMESMeshFile = "{}/Mesh.med".format(ERMESdir)
    shutil.copy("{}/{}.med".format(VL.MESH_DIR,Parameters.MeshERMES),ERMESMeshFile)

    # ==========================================================================
    # get mesh information in to ermes format
    print('Prep')
    Prep(ERMESMeshFile,ERMESdir)

    # local_ermes = "{}/ermes_dir".format(SimDict['CALC_DIR'])
    # if os.path.isdir(local_ermes):
    #     shutil.rmtree(local_ermes)
        
    # ==========================================================================
    # Create static files & run
    # the static analysis gives the current density in the coil
    print('Static')
    static_name = Static(Parameters,ERMESMeshFile,ERMESdir)
    err = ERMESRun(static_name)
    static_resfile = "{}.post.res".format(static_name)
    static_res = ERMES_Conversion(static_resfile, ERMESMeshFile)

    # calculate the current at the input terminal
    area,coil_current,coil_currentsq = CalculateCurrent(ERMESMeshFile)

    # scale resulting currents to ensure a current of 1 is recorded at input temrinal
    scale_factor = 1/coil_current

    JSource = np.loadtxt("{}/Exp_J_Sources/ExpJSource-1.dat".format(ERMESdir),skiprows=1)
    sourcestring = '0\n'
    for source in JSource:
        elems = "{}  {}  {}  {}  ".format(*source[:4].astype('int'))
        vals = "{:.4f}  {:.4f}  {:.4f}\n".format(*source[4:]*scale_factor)
        newstr = elems+vals
        sourcestring+=newstr

    with open("{}/Exp_J_Sources/ExpJSource-1.dat".format(ERMESdir),'w+') as f:
        f.write(sourcestring)

    # ==========================================================================
    # Create wave files & run
    print('Wave')
    wave_name = Wave(VL,Parameters,ERMESMeshFile,ERMESdir)
    err = ERMESRun(wave_name)
    wave_resfile = "{}.post.res".format(wave_name)
    wave_res = ERMES_Conversion(wave_resfile, ERMESMeshFile)

    # ==========================================================================
    # Copy files
    shutil.copy2("{}/ERMESLog".format(ERMESdir), os.path.dirname(SimDict['ERMES_ResFile']))
    shutil.copy2(ERMESMeshFile,SimDict['ERMES_ResFile'])
    # shutil.copytree(ERMESdir,local_ermes)