import sys
sys.dont_write_bytecode=True
import os
import numpy as np
import time as tm
from Utilitai import partition

import AsterFunc
import Parameters
import PathVL

def TempChange(ResName):
	Temp_1 = CREA_CHAMP(INFO=1, NOM_CHAM='TEMP', NUME_ORDRE=(ResName.LIST_VARI_ACCES()['NUME_ORDRE'])[-1], OPERATION='EXTR', RESULTAT=ResName, TYPE_CHAM='NOEU_TEMP_R')
	NTemp_1 = np.array(Temp_1.EXTR_COMP().valeurs)
	Temp_2 = CREA_CHAMP(INFO=1, NOM_CHAM='TEMP', NUME_ORDRE=(ResName.LIST_VARI_ACCES()['NUME_ORDRE'])[-2], OPERATION='EXTR', RESULTAT=ResName, TYPE_CHAM='NOEU_TEMP_R') 
	NTemp_2 = np.array(Temp_2.EXTR_COMP().valeurs)
	DETRUIRE(CONCEPT=_F(NOM=(Temp_1,Temp_2)))
	change = NTemp_1 = NTemp_2
	return change, NTemp_1

def EMvals(Nodes,Temperatures,EMTemps,EMdat):
	lis1 = []
	for i,node in enumerate(Nodes):
		if type(Temperatures) in (float,int):
			lis1.append(np.interp(Temperatures,EMTemps,EMdat[node,:]))
		else:
			lis1.append(np.interp(Temperatures[i],EMTemps,EMdat[node,:]))

	lis1 = np.array(lis1)
	return lis1


DEBUT(PAR_LOT = 'NON',LANG='EN')

##### Read in the mesh and define the model #####
mesh = LIRE_MAILLAGE(FORMAT='MED',UNITE=20)
Thermod = AFFE_MODELE(AFFE=_F(MODELISATION=(Parameters.Model),
	                      PHENOMENE='THERMIQUE',
	                      TOUT='OUI'),
	             	      MAILLAGE=mesh)

mesht = partition.MAIL_PY()
mesht.FromAster(mesh)

NNodes = len(mesht.cn)
EMdat = np.fromfile('{}/ERMES_Node.dat'.format(PathVL.TMP_CALC_DIR),dtype=float,count=-1,sep=" ")
#EMdat = EMdat.reshape((NNodes+1,len(EMdat)//(NNodes+1)))
#Temps, JouleHeat = EMdat[0,:], EMdat[1:,:]
Temps, JouleHeat = EMdat[0], EMdat[1:]
JHmean = np.mean(JouleHeat)

count = 0
ld = [None]
meshlist, Load_EM = [], []
for grp in Parameters.Materials.keys():
	for i, ElNum in enumerate(mesht.gma.get(grp)):
		Connect = mesht.co[ElNum]
#		JHelem = np.sum(JouleHeat[Connect,:],axis=0)/4
		JHelem = np.mean(JouleHeat[Connect])
		if JHelem < JHmean: continue

		meshlist.append(_F(GROUP_MA=(grp), NOM='M{}'.format(ElNum), NUME_FIN=i+1, NUME_INIT=i+1))
		Load_EM.append((_F(GROUP_MA=('M{}'.format(ElNum), ),SOUR=JHelem*1e6)))

		ld.append(None)
		count = count+1

DEFI_GROUP(reuse=mesh,
	   MAILLAGE=mesh,
	   CREA_GROUP_MA=meshlist)

EMI = AFFE_CHAR_THER(SOURCE = Load_EM, MODELE=Thermod)

##### Define functions for NL material properties and assign materials to parts #####
DictMat = AsterFunc.MaterialProps(PathVL.MATERIAL_DIR,Parameters.Materials.values())

BlockRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Block']]["RhoCp"])
BlockLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Block']]["Lambda"])
BlockMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA=BlockLAM, RHO_CP=BlockRCP))

PipeRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Pipe']]["RhoCp"])
PipeLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Pipe']]["Lambda"])
PipeMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA=PipeLAM, RHO_CP=PipeRCP))

TileRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Tile']]["RhoCp"])
TileLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Tile']]["Lambda"])
TileMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA=TileLAM, RHO_CP=TileRCP))

Thermat = AFFE_MATERIAU(AFFE=(_F(MATER=TileMat, GROUP_MA='Tile'),_F(MATER=PipeMat, GROUP_MA='Pipe'),_F(MATER=BlockMat, GROUP_MA='Block')),
	                MAILLAGE=mesh)

##### Create BCs #####

### BC for Pipe - Import Heat transfer coefficient and apply to pipe surface
PipeHTCdat = np.fromfile('{}/HTC.dat'.format(PathVL.TMP_CALC_DIR),dtype=float,count=-1,sep=" ")
HTC_Temps, HTC_Values = PipeHTCdat[::2], PipeHTCdat[1::2]
HTC_Temps = np.hstack((HTC_Temps[0]-1,HTC_Temps,HTC_Temps[-1]+1))
HTC_Values = np.hstack((HTC_Values[0],HTC_Values,HTC_Values[-1]))

PipeFluxdat = [None]*(len(HTC_Temps)*2)
PipeFluxdat[::2], PipeFluxdat[1::2] = HTC_Temps, -HTC_Values*(HTC_Temps - Parameters.Coolant['Temperature'])

PipeFlux = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='LINEAIRE',
		       PROL_GAUCHE='LINEAIRE',
	               VALE=PipeFluxdat)

PipeHTC = AFFE_CHAR_THER_F(FLUX_NL=_F(FLUN=PipeFlux,GROUP_MA=('PipeFace')),
			  MODELE=Thermod)

PipeArea,PipeFaceNodes = AsterFunc.BCinfo(mesh,Group = 'PipeFace')[0:2]

### BC for coil heating

## Uniform heatflux

#UniFlux = DEFI_CONSTANTE(VALE=1e5)
#EMI = AFFE_CHAR_THER_F(FLUX_REP=_F(FLUN=UniFlux, GROUP_MA=('CoilFace', )),MODELE=Thermod)
		  
## EM loads using ERMES




#EMI = AFFE_CHAR_THER_F(SOUR_NL = EMloads, MODELE=Thermod)

Loading = (_F(CHARGE=EMI),_F(CHARGE=PipeHTC))

##### Create list of time steps #####
start = 0
timelist, savelist = [], []
for i, tup in enumerate(Parameters.dt):
	if len(tup) == 3: dt, Nstep, save = tup
	else :dt, Nstep, save = tup[0],tup[1], 1

	fintime = start + dt*Nstep
	timesteps = np.linspace(start,fintime,Nstep+1).tolist()

	if i == 0: 
		timelist.append(timesteps)
		savelist.append(timesteps[::save])
	else: 
		timelist.append(timesteps[1:])
		savelist.append(timesteps[save::save])

	start = fintime

timearr = timearrOrig = np.concatenate(timelist)
savearr = np.concatenate(savelist)


##### Run thermal analysis #####
MaxIter = getattr(Parameters,'MaxIter',10)

### No results to import so we start with the initial temperature
if Parameters.ImportRes not in ('Yes','Y','yes','y'):
	StartTime = 0
	### Create field of temperatures loaded with initial temperature
	field = CREA_CHAMP(AFFE=_F(NOM_CMP='TEMP',TOUT='OUI',VALE=Parameters.InitTemp),MAILLAGE=mesh,OPERATION='AFFE',TYPE_CHAM='NOEU_TEMP_R')
	resther = CREA_RESU(AFFE=_F(CHAM_GD=field,INST=0.0),NOM_CHAM='TEMP',OPERATION='AFFE',TYPE_RESU='EVOL_THER')

#	if Parameters.CheckFirst == 0:FinIx = TotStep
#	else :FinIx = min(Parameters.CheckFirst,TotStep)
	FinIx = len(timearr)-1

### Import starting temperature profile from results
else:
	### Import results to create field of temperatures
	DEFI_FICHIER(FICHIER=PathVL.RESULTS_DIR + '/ResTher.rmed', UNITE=40)		
	resther = LIRE_RESU(FORMAT='MED',
			    FORMAT_MED=_F(NOM_CHAM='TEMP',
			    NOM_RESU='resther'),
			    MAILLAGE=mesh,
			    TOUT_ORDRE='OUI',
			    TYPE_RESU='EVOL_THER',
			    UNITE=40)
	StartTime = (resther.LIST_VARI_ACCES()['INST'])[-1]
	NewIndex = np.argmin(abs(timearr - StartTime))

	if os.path.isfile(Info.DATA_DIR + '/TimeSteps.dat'):
		PrevTime = np.fromfile(Info.DATA_DIR + '/TimeSteps.dat',dtype=float,count=-1,sep=' ')
		ImportIndex = np.argmin(abs(PrevTime - StartTime))
		timearr = np.concatenate((PrevTime[0:ImportIndex+1],timearr[NewIndex+1:]))
	else:
		ImportIndex = 0
		timearr = timearr[NewIndex:]

	TotStep = len(timearr) - 1
	if Parameters.CheckFirst == 0:
		FinIx = TotStep
	else :
		FinIx = min(ImportIndex + Parameters.CheckFirst,TotStep)


### Create list of timesteps and list of steps to save
timestp1 = DEFI_LIST_REEL(VALE=timearr)
Storing = DEFI_LIST_REEL(VALE=savearr)

# Start  thermal analysis
AdaptSteps = AsterFunc.AdaptThermal(resther,timestp1,Loading,Thermat,Thermod,Parameters.Theta,Parameters.Solver,Storing = Storing, MaxIter=MaxIter,EndIndex = FinIx)

## continue thermal analysis
#while FinIx < TotStep: 
#	if Parameters.CheckEvery == 0:
#		FinIx = TotStep
#	else :
#		FinIx = min(FinIx + Parameters.CheckEvery,TotStep)

#	newSteps = AsterFunc.AdaptThermal(resther,timestp1,Loading,Thermat,Thermod,Parameters.Theta,Parameters.Solver,Storing = Storing, MaxIter=MaxIter,EndIndex = FinIx)
#	AdaptSteps = np.concatenate((AdaptSteps,newSteps[1:]))

np.savetxt('./REPE_OUT/TimeSteps.dat', timearr, fmt = '%.6f', delimiter = '   ')
DEFI_FICHIER(FICHIER='./REPE_OUT/ResTher.rmed', TYPE='BINARY', UNITE=80)
IMPR_RESU(RESU=_F(RESULTAT=resther), UNITE=80)

FIN()
