import os
import sys
import numpy as np

from Utilitai import partition
import AsterFunc
import aster
sys.dont_write_bytecode=True
########################################################################################################################

sys.path.insert(0,os.path.dirname(TMP_FILE))
Info = __import__(os.path.basename(os.path.splitext(TMP_FILE)[0]))
Parameters = __import__(Info.PARAM_MOD)

##########################################################################################################################

def TempChange(ResName):
	Temp_1 = CREA_CHAMP(INFO=1, NOM_CHAM='TEMP', NUME_ORDRE=(ResName.LIST_VARI_ACCES()['NUME_ORDRE'])[-1], OPERATION='EXTR', RESULTAT=ResName, TYPE_CHAM='NOEU_TEMP_R')
	NTemp_1 = np.array(Temp_1.EXTR_COMP().valeurs)
	Temp_2 = CREA_CHAMP(INFO=1, NOM_CHAM='TEMP', NUME_ORDRE=(ResName.LIST_VARI_ACCES()['NUME_ORDRE'])[-2], OPERATION='EXTR', RESULTAT=ResName, TYPE_CHAM='NOEU_TEMP_R')
	NTemp_2 = np.array(Temp_2.EXTR_COMP().valeurs)
	DETRUIRE(CONCEPT=_F(NOM=(Temp_1,Temp_2)))
	change = NTemp_1 = NTemp_2
	return change, NTemp_1

def EMvals(Nodes,Temperatures,EMTemps,EMdat):
	lis1 = []
	for i,node in enumerate(Nodes):
		if type(Temperatures) in (float,int):
			lis1.append(np.interp(Temperatures,EMTemps,EMdat[node,:]))
		else:
			lis1.append(np.interp(Temperatures[i],EMTemps,EMdat[node,:]))

	lis1 = np.array(lis1)
	return lis1


DEBUT(PAR_LOT = 'NON',LANG='EN')

##### Read in the mesh and define the model #####
mesh = LIRE_MAILLAGE(FORMAT='MED',UNITE=20)
Thermod = AFFE_MODELE(AFFE=_F(MODELISATION=(Parameters.Model, ),
	                      PHENOMENE='THERMIQUE',
	                      TOUT='OUI'),
	             	      MAILLAGE=mesh)


##### Define functions for NL material properties and assign materials to parts #####
DictMat = AsterFunc.MaterialProps(Info.MATERIAL_DIR,Parameters.Materials.values())

BlockRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Block']]["RhoCp"])
BlockLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Block']]["Lambda"])
BlockMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA=BlockLAM, RHO_CP=BlockRCP))

PipeRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Pipe']]["RhoCp"])
PipeLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Pipe']]["Lambda"])
PipeMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA=PipeLAM, RHO_CP=PipeRCP))

TileRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Tile']]["RhoCp"])
TileLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Tile']]["Lambda"])
TileMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA=TileLAM, RHO_CP=TileRCP))

Thermat = AFFE_MATERIAU(AFFE=(_F(MATER=TileMat, GROUP_MA='Tile'),_F(MATER=PipeMat, GROUP_MA='Pipe'),_F(MATER=BlockMat, GROUP_MA='Block')),
	                MAILLAGE=mesh)

##### Create BCs #####

### BC for Pipe - Import Heat transfer coefficient and apply to pipe surface
PipeHTCdat = np.fromfile(os.path.dirname(TMP_FILE) + '/HTC.dat',dtype=float,count=-1,sep=" ")
HTC_Temps, HTC_Values = PipeHTCdat[::2], PipeHTCdat[1::2]
HTC_Temps = np.hstack((HTC_Temps[0]-1,HTC_Temps,HTC_Temps[-1]+1))
HTC_Values = np.hstack((HTC_Values[0],HTC_Values,HTC_Values[-1]))

PipeFluxdat = [None]*(len(HTC_Temps)*2)
PipeFluxdat[::2], PipeFluxdat[1::2] = HTC_Temps, -HTC_Values*(HTC_Temps - Parameters.FluidT)

PipeFlux = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='LINEAIRE',
		       PROL_GAUCHE='LINEAIRE',
	               VALE=PipeFluxdat)

PipeHTC = AFFE_CHAR_THER_F(FLUX_NL=_F(FLUN=PipeFlux,GROUP_MA=('PipeFace')),
			  MODELE=Thermod)

PipeArea,PipeFaceNodes = AsterFunc.BCinfo(mesh,Group = 'PipeFace')[0:2]

### Create BCs
## Coil BC
if Parameters.EMLoad == 'Uniform':
	EMI = AFFE_CHAR_THER(FLUX_REP=_F(FLUN=Parameters.Flux, GROUP_MA='CoilFace'),MODELE=Thermod)
elif Parameters.EMLoad == 'ERMES':
	# Read in ERMES file created during PreAster
	ERMES = np.load('{}/ERMES.npy'.format(PathVL.TMP_CALC_DIR))
	Load_EM = []
	for i,JH in enumerate(ERMES):
		Load_EM.append((_F(GROUP_MA="_{}".format(i),SOUR=JH)))
	EMI = AFFE_CHAR_THER(SOURCE = Load_EM, MODELE=Thermod)

CoilVol,CoilNodes = AsterFunc.BCinfo(mesh,Elements = Elem_EM)[0:2]

Loading = (_F(CHARGE=EMI),_F(CHARGE=PipeHTC))

##### Create list of time steps #####
fintime, TotStep, start = 0, 0, 0
timelist = [np.array([start])]
for tup in Parameters.dt:
	dt, Nstep = tup
	TotStep += Nstep
	fintime += dt*Nstep
	timelist.append(np.linspace(start+dt,fintime,Nstep))
	start = fintime
timearr = timearrOrig = np.concatenate(timelist)

##### Run thermal analysis #####
MaxIter = getattr(Parameters,'MaxIter',10)

### No results to import so we start with the initial temperature
if Parameters.ImportRes not in ('Yes','Y','yes','y'):
	StartTime = 0
	### Create field of temperatures loaded with initial temperature
	field = CREA_CHAMP(AFFE=_F(NOM_CMP='TEMP',TOUT='OUI',VALE=Parameters.InitTemp),MAILLAGE=mesh,OPERATION='AFFE',TYPE_CHAM='NOEU_TEMP_R')
	resther = CREA_RESU(AFFE=_F(CHAM_GD=field,INST=0.0),NOM_CHAM='TEMP',OPERATION='AFFE',TYPE_RESU='EVOL_THER')

	### Calculate the power going in to the sample initially
#	PipePower = np.sum(PipeArea)*np.interp(Parameters.InitTemp,PipeFluxdat[0::2],PipeFluxdat[1::2])
#	CoilPower = np.dot(EMvals(CoilNodes,Parameters.InitTemp,EMTemps,scaling*JouleHeat),CoilVol)
#	PowerIn = PipePower + CoilPower
#	print('Power input: {:.4f} (Pipe:{:.4f}, Coil:{:.4f})'.format(PowerIn,PipePower,CoilPower))
#	Convergence = np.array([0,0,PowerIn])

	if Parameters.CheckFirst == 0:
		FinIx = TotStep
	else :
		FinIx = min(Parameters.CheckFirst,TotStep)

### Import starting temperature profile from results
else:
	### Import results to create field of temperatures
	DEFI_FICHIER(FICHIER=Info.RESULTS_DIR + '/ResTher.rmed', UNITE=40)
	resther = LIRE_RESU(FORMAT='MED',
			    FORMAT_MED=_F(NOM_CHAM='TEMP',
			    NOM_RESU='resther'),
			    MAILLAGE=mesh,
			    TOUT_ORDRE='OUI',
			    TYPE_RESU='EVOL_THER',
			    UNITE=40)
	StartTime = (resther.LIST_VARI_ACCES()['INST'])[-1]
	NewIndex = np.argmin(abs(timearr - StartTime))

	if os.path.isfile(Info.DATA_DIR + '/TimeSteps.dat'):
		PrevTime = np.fromfile(Info.DATA_DIR + '/TimeSteps.dat',dtype=float,count=-1,sep=' ')
		ImportIndex = np.argmin(abs(PrevTime - StartTime))
		timearr = np.concatenate((PrevTime[0:ImportIndex+1],timearr[NewIndex+1:]))
	else:
		ImportIndex = 0
		timearr = timearr[NewIndex:]

	TotStep = len(timearr) - 1
	if Parameters.CheckFirst == 0:
		FinIx = TotStep
	else :
		FinIx = min(ImportIndex + Parameters.CheckFirst,TotStep)

#	PrevConv = np.fromfile(Info.DATA_DIR + '/Convergence.dat',dtype=float,count=-1,sep=' ')
#	PrevConv = np.reshape(PrevConv,(len(PrevConv)/4,4))
#	Convergence = (PrevConv[PrevConv[:,1]<=ImportIndex])


### Create list of timesteps and list of steps to save
timestp1 = DEFI_LIST_REEL(VALE=timearr)
Storing = DEFI_LIST_REEL(VALE=timearr[::Parameters.ResStore])

AdaptSteps = AsterFunc.AdaptThermal(resther,timestp1,Loading,Thermat,Thermod,Parameters.Theta,Parameters.Solver,Storing = Storing, MaxIter=MaxIter,EndIndex = FinIx)

#DiffTemp, CurrTemp = TempChange(resther)
#MaxChange = max(abs(DiffTemp))


### Calculate the power going in to the sample after some time
#PipePower = np.dot(np.interp(CurrTemp[PipeFaceNodes],PipeFluxdat[0::2],PipeFluxdat[1::2]),PipeArea)
#CoilPower = np.dot(EMvals(CoilNodes,CurrTemp[CoilNodes],EMTemps,scaling*JouleHeat),CoilVol)
#PowerIn = PipePower + CoilPower
#Indic = np.array([AdaptSteps[-1],MaxChange,PowerIn])
#Convergence = np.vstack((Convergence,Indic))
#print('Max temperature change: {}'.format(MaxChange))
#print('Power input: {:.4f} (Pipe:{:.4f}, Coil:{:.4f})'.format(PowerIn,PipePower,CoilPower))


while FinIx < TotStep:
	if Parameters.CheckEvery == 0:
		FinIx = TotStep
	else :
		FinIx = min(FinIx + Parameters.CheckEvery,TotStep)

	newSteps = AsterFunc.AdaptThermal(resther,timestp1,Loading,Thermat,Thermod,Parameters.Theta,Parameters.Solver,Storing = Storing, MaxIter=MaxIter,EndIndex = FinIx)
	AdaptSteps = np.concatenate((AdaptSteps,newSteps[1:]))

#	DiffTemp, CurrTemp = TempChange(resther)
#	MaxChange = max(abs(DiffTemp))

#	### Calculate the power going in to the sample after some time
#	PipePower = np.dot(np.interp(CurrTemp[PipeFaceNodes],PipeFluxdat[0::2],PipeFluxdat[1::2]),PipeArea)
#	CoilPower = np.dot(EMvals(CoilNodes,CurrTemp[CoilNodes],EMTemps,scaling*JouleHeat),CoilVol)
#	PowerIn = PipePower + CoilPower
#	Indic = np.array([AdaptSteps[-1],MaxChange,PowerIn])
#	Convergence = np.vstack((Convergence,Indic))
#	print('Max temperature change: {}'.format(MaxChange))
#	print('Power input: {:.4f} (Pipe:{:.4f}, Coil:{:.4f})'.format(PowerIn,PipePower,CoilPower))

np.savetxt('./REPE_OUT/TimeSteps.dat', timearr, fmt = '%.6f', delimiter = '   ')
DEFI_FICHIER(FICHIER='./REPE_OUT/ResTher.rmed', TYPE='BINARY', UNITE=80)
IMPR_RESU(RESU=_F(RESULTAT=resther), UNITE=80)

FIN()
