import sys
sys.dont_write_bytecode=True
import os
import numpy as np
import time
from Utilitai import partition

import AsterFunc
import Parameters
import PathVL


DEBUT(PAR_LOT = 'NON',LANG='EN')

##### Read in the mesh and define the model #####
st = time.time()
mesh = LIRE_MAILLAGE(FORMAT='MED',UNITE=20)
meshin = time.time()-st
Thermod = AFFE_MODELE(AFFE=_F(MODELISATION=(Parameters.Model),
	                      PHENOMENE='THERMIQUE',
	                      TOUT='OUI'),
	             	      MAILLAGE=mesh)

##### Define functions for NL material properties and assign materials to parts #####
DictMat = AsterFunc.MaterialProps(PathVL.MATERIAL_DIR,Parameters.Materials.values())

BlockRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Block']]["RhoCp"])
BlockLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Block']]["Lambda"])
BlockMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA=BlockLAM, RHO_CP=BlockRCP))

PipeRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Pipe']]["RhoCp"])
PipeLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Pipe']]["Lambda"])
PipeMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA=PipeLAM, RHO_CP=PipeRCP))

TileRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Tile']]["RhoCp"])
TileLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Tile']]["Lambda"])
TileMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA=TileLAM, RHO_CP=TileRCP))

Thermat = AFFE_MATERIAU(AFFE=(_F(MATER=TileMat, GROUP_MA='Tile'),_F(MATER=PipeMat, GROUP_MA='Pipe'),_F(MATER=BlockMat, GROUP_MA='Block')),
	                MAILLAGE=mesh)

##### Create BCs #####
##### Create BCs #####
if Parameters.EMLoad == 'Uniform':
	EMI = AFFE_CHAR_THER(FLUX_REP=_F(FLUN=Parameters.Flux, GROUP_MA='CoilFace'),MODELE=Thermod)
elif Parameters.EMLoad == 'ERMES':
	### BC for coil heating
	ERMES = np.load('{}/ERMES.npy'.format(PathVL.TMP_CALC_DIR))
	Els, JouleHeat = ERMES[:,0],ERMES[:,1]

	### Linear
	# Create groups in Aster
	if False:
		mesht = partition.MAIL_PY()
		mesht.FromAster(mesh)
		st = time.time()
		ls = mesht.gma.get('Sample')
		ElemIx = np.searchsorted(ls,Els-1)

		meshlist, Load_EM = [], []
		for i, (JH, Ix) in enumerate(zip(JouleHeat,ElemIx)):
			name = 'M{}'.format(i)
			meshlist.append(_F(GROUP_MA='Sample', NOM=name, NUME_INIT=Ix+1, NUME_FIN=Ix+1))
			Load_EM.append((_F(GROUP_MA=name,SOUR=JH)))

		st = time.time()
		DEFI_GROUP(reuse=mesh,MAILLAGE=mesh,CREA_GROUP_MA=meshlist)
		create = time.time()-st
		print("Create:{}, ReadIn:{}".format(create,meshin))

	else:
		# Groups created PreAster - substantial reading in overheads
		Load_EM = []
		for El, JH in zip(Els,JouleHeat):
			Load_EM.append((_F(GROUP_MA="M{}".format(int(El)),SOUR=JH)))
		print("ReadIn:{}".format(meshin))

	# st = time.time()
	# EMI = AFFE_CHAR_THER(SOURCE = Load_EM, MODELE=Thermod) # Linear
	# print(time.time()-st)

	# Non-linear
	# st = time.time()
	# ld = [None]*Els.shape[0
	# for i, (JH, Ix) in enumerate(zip(JouleHeat,ElemIx)):
	# 	name = 'M{}'.format(i)
	# 	meshlist.append(_F(GROUP_MA='Sample', NOM=name, NUME_INIT=Ix+1, NUME_FIN=Ix+1))
	# 	Non-linear analysis
	# 	ld[i] = DEFI_CONSTANTE(VALE=JH)
	# 	Load_EM.append((_F(GROUP_MA=name,SOUR=ld[i])))
	# print(time.time()-st)
	# st = time.time()
	# DEFI_GROUP(reuse=mesh,MAILLAGE=mesh,CREA_GROUP_MA=meshlist)
	# print(time.time()-st)
	# st = time.time()
	# EMI = AFFE_CHAR_THER_F(SOURCE = Load_EM, MODELE=Thermod) # Non-linear
	# print(time.time()-st)

'''
### BC for Pipe - Import Heat transfer coefficient and apply to pipe surface
PipeHTCdat = np.fromfile('{}/HTC.dat'.format(PathVL.TMP_CALC_DIR),dtype=float,count=-1,sep=" ")
HTC_Temps, HTC_Values = PipeHTCdat[::2], PipeHTCdat[1::2]
HTC_Temps = np.hstack((HTC_Temps[0]-1,HTC_Temps,HTC_Temps[-1]+1))
HTC_Values = np.hstack((HTC_Values[0],HTC_Values,HTC_Values[-1]))

PipeFluxdat = [None]*(len(HTC_Temps)*2)
PipeFluxdat[::2], PipeFluxdat[1::2] = HTC_Temps, -HTC_Values*(HTC_Temps - Parameters.Coolant['Temperature'])

PipeFlux = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='LINEAIRE',
		       PROL_GAUCHE='LINEAIRE',
	               VALE=PipeFluxdat)

PipeHTC = AFFE_CHAR_THER_F(FLUX_NL=_F(FLUN=PipeFlux,GROUP_MA=('PipeFace')),
			  MODELE=Thermod)

PipeArea,PipeFaceNodes = AsterFunc.BCinfo(mesh,Group = 'PipeFace')[0:2]

## Loads
Loading = (_F(CHARGE=EMI),_F(CHARGE=PipeHTC))

### Get timesteps and savesteps using dt provided in Parameters ###
timearr, savearr = AsterFunc.Timesteps(Parameters.dt)
Timestp = DEFI_LIST_REEL(VALE=timearr)
Savestp = DEFI_LIST_REEL(VALE=savearr)

### Temperature distribution to start simulation
field = CREA_CHAMP(AFFE=_F(NOM_CMP='TEMP',TOUT='OUI',VALE=Parameters.InitTemp),MAILLAGE=mesh,OPERATION='AFFE',TYPE_CHAM='NOEU_TEMP_R')
resther = CREA_RESU(AFFE=_F(CHAM_GD=field,INST=0.0),NOM_CHAM='TEMP',OPERATION='AFFE',TYPE_RESU='EVOL_THER')

## Start  thermal analysis ##
Theta = getattr(Parameters,'Theta',0.5)
Solver = getattr(Parameters,'Solver', 'MUMPS')
MaxIter = getattr(Parameters,'MaxIter',10)

AdaptSteps = AsterFunc.AdaptThermal(resther,Timestp,Loading,Thermat,Thermod,Theta,Solver,Storing = Savestp, MaxIter=MaxIter)


np.savetxt('./REPE_OUT/TimeSteps.dat', timearr, fmt = '%.6f', delimiter = '   ')
DEFI_FICHIER(FICHIER='./REPE_OUT/ResTher.rmed', TYPE='BINARY', UNITE=80)
IMPR_RESU(RESU=_F(RESULTAT=resther), UNITE=80)
'''
FIN()
