import sys
sys.dont_write_bytecode=True
import os
import numpy as np
import time
from Utilitai import partition

import AsterFunc
import Parameters
import PathVL

def MaxChange(ResName):
	Temp_1 = CREA_CHAMP(INFO=1, NOM_CHAM='TEMP', NUME_ORDRE=(ResName.LIST_VARI_ACCES()['NUME_ORDRE'])[-1], OPERATION='EXTR', RESULTAT=ResName, TYPE_CHAM='NOEU_TEMP_R')
	Temp_2 = CREA_CHAMP(INFO=1, NOM_CHAM='TEMP', NUME_ORDRE=(ResName.LIST_VARI_ACCES()['NUME_ORDRE'])[-2], OPERATION='EXTR', RESULTAT=ResName, TYPE_CHAM='NOEU_TEMP_R')
	Resid = np.max(np.abs(np.array(Temp_1.EXTR_COMP().valeurs) - np.array(Temp_2.EXTR_COMP().valeurs)))
	DETRUIRE(CONCEPT=_F(NOM=(Temp_1,Temp_2)))
	return Resid

def EMvals(Nodes,Temperatures,EMTemps,EMdat):
	lis1 = []
	for i,node in enumerate(Nodes):
		if type(Temperatures) in (float,int):
			lis1.append(np.interp(Temperatures,EMTemps,EMdat[node,:]))
		else:
			lis1.append(np.interp(Temperatures[i],EMTemps,EMdat[node,:]))

	lis1 = np.array(lis1)
	return lis1


DEBUT(PAR_LOT = 'NON',LANG='EN')

##### Read in the mesh and define the model #####
mesh = LIRE_MAILLAGE(FORMAT='MED',UNITE=20)

Thermod = AFFE_MODELE(AFFE=_F(MODELISATION=(Parameters.Model),
	                      PHENOMENE='THERMIQUE',
	                      TOUT='OUI'),
	             	      MAILLAGE=mesh)

##### Define functions for NL material properties and assign materials to parts #####
DictMat = AsterFunc.MaterialProps(PathVL.MATERIAL_DIR,Parameters.Materials.values())

BlockRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Block']]["RhoCp"])
BlockLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Block']]["Lambda"])
BlockMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA=BlockLAM, RHO_CP=BlockRCP))

PipeRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Pipe']]["RhoCp"])
PipeLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Pipe']]["Lambda"])
PipeMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA=PipeLAM, RHO_CP=PipeRCP))

TileRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Tile']]["RhoCp"])
TileLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Tile']]["Lambda"])
TileMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA=TileLAM, RHO_CP=TileRCP))

Thermat = AFFE_MATERIAU(AFFE=(_F(MATER=TileMat, GROUP_MA='Tile'),_F(MATER=PipeMat, GROUP_MA='Pipe'),_F(MATER=BlockMat, GROUP_MA='Block')),
	                MAILLAGE=mesh)

##### Create BCs #####
### BC for coil heating
mesht = partition.MAIL_PY()
mesht.FromAster(mesh)

ERMES = np.load('{}/ERMES.npy'.format(PathVL.TMP_CALC_DIR))
Els, JouleHeat = ERMES[:,0],ERMES[:,1]
NbEls = Els.shape[0]

ls = mesht.gma.get('Sample')

st = time.time()

ElemIx = np.searchsorted(ls,Els-1)
EM_Els, meshlist, Load_EM, ld = [], [], [], [None]*NbEls

for i, (JH, Ix) in enumerate(zip(JouleHeat,ElemIx)):
	name = 'M{}'.format(i)
	meshlist.append(_F(GROUP_MA='Sample', NOM=name, NUME_INIT=Ix+1, NUME_FIN=Ix+1))
	ld[i] = DEFI_CONSTANTE(VALE=JH)
	Load_EM.append((_F(GROUP_MA=name,SOUR=ld[i])))
	EM_Els.append(name)

print(time.time()-st)

st = time.time()
DEFI_GROUP(reuse=mesh,MAILLAGE=mesh,CREA_GROUP_MA=meshlist)
print(time.time()-st)

st = time.time()
EMI = AFFE_CHAR_THER_F(SOURCE = Load_EM, MODELE=Thermod)
print(time.time()-st)

### BC for Pipe - Import Heat transfer coefficient and apply to pipe surface
PipeHTCdat = np.fromfile('{}/HTC.dat'.format(PathVL.TMP_CALC_DIR),dtype=float,count=-1,sep=" ")
HTC_Temps, HTC_Values = PipeHTCdat[::2], PipeHTCdat[1::2]
HTC_Temps = np.hstack((HTC_Temps[0]-1,HTC_Temps,HTC_Temps[-1]+1))
HTC_Values = np.hstack((HTC_Values[0],HTC_Values,HTC_Values[-1]))

PipeFluxdat = [None]*(len(HTC_Temps)*2)
PipeFluxdat[::2], PipeFluxdat[1::2] = HTC_Temps, -HTC_Values*(HTC_Temps - Parameters.Coolant['Temperature'])

PipeFlux = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='LINEAIRE',
		       PROL_GAUCHE='LINEAIRE',
	               VALE=PipeFluxdat)

PipeHTC = AFFE_CHAR_THER_F(FLUX_NL=_F(FLUN=PipeFlux,GROUP_MA=('PipeFace')),
			  MODELE=Thermod)

# PipeArea,PipeFaceNodes = AsterFunc.BCinfo(mesh,Group = 'PipeFace')[0:2]

## Loads
Loading = (_F(CHARGE=EMI),_F(CHARGE=PipeHTC))

### Get timesteps and savesteps using dt provided in Parameters ###
timearr, savearr = AsterFunc.Timesteps(Parameters.dt)
Timestp = DEFI_LIST_REEL(VALE=timearr)
Savestp = DEFI_LIST_REEL(VALE=savearr)


### Temperature distribution to start simulation
field = CREA_CHAMP(AFFE=_F(NOM_CMP='TEMP',TOUT='OUI',VALE=Parameters.InitTemp),MAILLAGE=mesh,OPERATION='AFFE',TYPE_CHAM='NOEU_TEMP_R')
resther = CREA_RESU(AFFE=_F(CHAM_GD=field,INST=0.0),NOM_CHAM='TEMP',OPERATION='AFFE',TYPE_RESU='EVOL_THER')

## Convergence indexing
Nstep = timearr.shape[0]-1
ConvGap = Parameters.Convergence.get('Gap', 0)
if ConvGap:
	ConvStart = Parameters.Convergence.get('Start', ConvGap)
	CheckList = list(range(ConvStart,Nstep,ConvGap))
	CheckList.append(Nstep)
else:
	CheckList = [Nstep]

## Start  thermal analysis ##
Theta = getattr(Parameters,'Theta',0.5)
Solver = getattr(Parameters,'Solver', 'MUMPS')
MaxIter = getattr(Parameters,'MaxIter',10)
ConvRes = getattr(Parameters,'ConvRes',1e-5)

ConvFile = "{}/Convergence.dat".format(PathVL.ASTER)
# Create blank file

with open(ConvFile, 'w') as f: pass


TempConvergence = []
for i, CheckIx in enumerate(CheckList):
	NewTsteps = AsterFunc.AdaptThermal(resther,Timestp,Loading,Thermat,Thermod,Theta,Solver,Storing = Savestp, MaxIter=MaxIter, EndIndex=CheckIx)
	if i == 0: AdaptTsteps = NewTsteps
	else: AdaptTsteps+=NewTsteps[1:]

	Tempdiff = MaxChange(resther)
	TempConvergence.append(Tempdiff)
	with open(ConvFile, 'a') as f: f.write("{}\n".format(Tempdiff))

	if Tempdiff < ConvRes: break


# DETRUIRE(CONCEPT=_F(NOM=(mesh)))
# mesh = LIRE_MAILLAGE(FORMAT='MED',UNITE=20)

np.savetxt('./REPE_OUT/TimeSteps.dat', AdaptTsteps, delimiter = '   ')
DEFI_FICHIER(FICHIER='./REPE_OUT/{}.rmed'.format(Parameters.ResName), TYPE='BINARY', UNITE=80)
IMPR_RESU(RESU=_F(RESULTAT=resther), UNITE=80)

FIN()
