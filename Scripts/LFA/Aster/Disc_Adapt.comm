import sys
sys.dont_write_bytecode=True
import os
import numpy as np
import time as tm
from Utilitai import partition

import AsterFunc
import Parameters
import PathVL

def GaussProfile(x,y,sigma):
	z = (1/(2*pi*sigma**2))*np.exp(-(x**2+y**2)/(2*sigma**2))
	return z

DEBUT(PAR_LOT = 'NON',LANG='EN')
#from scipy import special
#Vlaser = special.erf(np.sqrt(0.0075*10**3)/(np.sqrt(2)*sigma*10**3))
#Vdisk = special.erf(np.sqrt(Parameters.Radius*10**3)/(np.sqrt(2)*sigma*10**3))
#E_exp = Parameters.Energy*Vdisk/Vlaser # Energy imparted in to system

##### Read in the mesh and define the model #####

mesh = LIRE_MAILLAGE(FORMAT='MED',UNITE=20)
mesht = partition.MAIL_PY()
mesht.FromAster('mesh')
	
Thermod = AFFE_MODELE(AFFE=_F(MODELISATION=(Parameters.Model, ),
	                      PHENOMENE='THERMIQUE',
	                      TOUT='OUI'),
	             	      MAILLAGE=mesh)

##### Define functions for NL material properties and assign materials to parts #####
DictMat = AsterFunc.MaterialProps(PathVL.MATERIAL_DIR, Parameters.Materials.values())
# Top Material
TopRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Top']]['RhoCp'])
TopLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Top']]['Lambda'])
TopMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA = TopLAM, RHO_CP = TopRCP))
# Bottom Material
BotRCP = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Bottom']]['RhoCp'])
BotLAM = DEFI_FONCTION(NOM_PARA='TEMP',
	               PROL_DROITE='CONSTANT',
		       PROL_GAUCHE='CONSTANT',
	               VALE=DictMat[Parameters.Materials['Bottom']]['Lambda'])
BotMat = DEFI_MATERIAU(THER_NL=_F(LAMBDA = BotLAM, RHO_CP = BotRCP))

Thermat = AFFE_MATERIAU(AFFE=(_F(MATER=TopMat, GROUP_MA='Top'),_F(MATER=BotMat, GROUP_MA='Bottom')),
	                MAILLAGE=mesh)

##### Create list of time steps #####
fintime, TotStep, start = 0, 0, 0
timelist = [np.array([start])]
for tup in Parameters.dt:
	dt, Nstep = tup
	TotStep += Nstep
	fintime += dt*Nstep
	timelist.append(np.linspace(start+dt,fintime,Nstep))
	start = fintime
timearr = timearrOrig = np.concatenate(timelist)

##### Create BCs #####

## Laser Temporal Profile
Lsrdat = np.fromfile('{}/Laser/{}.dat'.format(PathVL.SIM_SCRIPTS, Parameters.LaserT),dtype=float,count=-1,sep=" ")
LsrProf = DEFI_FONCTION(NOM_PARA='INST',
		       PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
		       VALE=Lsrdat)
Lsrdat = Lsrdat.reshape(int(len(Lsrdat)/2),2)
xlaser, flaser = Lsrdat[:,0], Lsrdat[:,1]
LaserArea = np.trapz(flaser, x=xlaser)

## Laser Spatial Profile
TopArea,TopNodes = AsterFunc.BCinfo(mesh,Group = 'Top_Face')[0:2]

if Parameters.LaserS == 'Uniform':
	Fn = Parameters.Energy/(sum(TopArea)*LaserArea)
	FluxProf = DEFI_CONSTANTE(VALE=Fn)
elif Parameters.LaserS in ('Gauss','gauss'):
	sigma = 0.005/(-2*np.log(1-0.1))**0.5 ### This value of sigma ensures a 10% reduction 5mm away from centre
	Coors = mesht.cn[TopNodes]
	x, y  = Coors[:,0], Coors[:,1]
	Gauss = GaussProfile(x,y,sigma)
	SumLoad = np.dot(TopArea, Gauss)
	Fn = Parameters.Energy/(SumLoad*LaserArea) ### Value Fn scales Gaussian profileto ensure correct energy input

	FluxProf = FORMULE(VALE='Fn*GaussProfile(X,Y,sigma)',
		       NOM_PARA=('X', 'Y'),sigma=sigma,Fn=Fn,GaussProfile=GaussProfile)

LaserOn = AFFE_CHAR_THER_F(FLUX_REP=_F(FLUN=FluxProf, GROUP_MA='Top_Face'),
			   MODELE=Thermod)

## Heat Transfer BC
BotHTC = DEFI_CONSTANTE(VALE=Parameters.BottomHTC)
TopHTC = DEFI_CONSTANTE(VALE=Parameters.TopHTC)
T_ext = DEFI_CONSTANTE(VALE=Parameters.ExtTemp)

HT = AFFE_CHAR_THER_F(ECHANGE=(_F(COEF_H=BotHTC, TEMP_EXT=T_ext, GROUP_MA='Bottom_Ext'), 
			       _F(COEF_H=TopHTC, TEMP_EXT=T_ext, GROUP_MA='Top_Ext')),
		      MODELE=Thermod)

## Loads
Loading1 = (_F(CHARGE=LaserOn, FONC_MULT=LsrProf),_F(CHARGE=HT))
Loading2 = (_F(CHARGE=HT))

### No results to import so we start with the initial temperature
if Parameters.ImportRes not in ('Yes','Y','yes','y'):
	StartTime = 0
	field = CREA_CHAMP(AFFE=_F(NOM_CMP='TEMP',TOUT='OUI',VALE=Parameters.InitTemp),MAILLAGE=mesh,OPERATION='AFFE',TYPE_CHAM='NOEU_TEMP_R')
	resther = CREA_RESU(AFFE=_F(CHAM_GD=field,INST=0.0),NOM_CHAM='TEMP',OPERATION='AFFE',TYPE_RESU='EVOL_THER')

### Import starting temperature profile from results
else:	
	DEFI_FICHIER(FICHIER=PathVL.RESULTS_DIR + '/ResTher.rmed', UNITE=40)		
	resther = LIRE_RESU(FORMAT='MED',
			    FORMAT_MED=_F(NOM_CHAM='TEMP',
			    NOM_RESU='resther'),
			    MAILLAGE=mesh,
			    TOUT_ORDRE='OUI',
			    TYPE_RESU='EVOL_THER',
			    UNITE=40)
	StartTime = (resther.LIST_VARI_ACCES()['INST'])[-1]
	NewIndex = np.argmin(abs(timearr - StartTime))

	if os.path.isfile(PathVL.DATA_DIR + '/TimeSteps.dat'):
		PrevTime = np.fromfile(PathVL.DATA_DIR + '/TimeSteps.dat',dtype=float,count=-1,sep=' ')
		ImportIndex = np.argmin(abs(PrevTime - StartTime))
		timearr = np.concatenate((PrevTime[0:ImportIndex+1],timearr[NewIndex+1:]))
	else:
		ImportIndex = 0
		timearr = timearr[NewIndex:]
	TotStep = len(timearr) - 1


MaxIter = getattr(Parameters, 'MaxIter', 10)
LPend = getattr(Parameters, 'LaserEnd', xlaser[-1])
LPindex = np.argmin(abs(timearr - LPend))

LaserStore = timearr[:LPindex+1:Parameters.Storing['Laser']]
PostLaserStore = timearr[LPindex+Parameters.Storing['PostLaser']::Parameters.Storing['PostLaser']]
Store = np.concatenate((LaserStore,PostLaserStore))
timestp = DEFI_LIST_REEL(VALE=timearr)
Storing = DEFI_LIST_REEL(VALE=Store)

### LaserOn
if  StartTime < LPend:
	FinIx = LPindex
	AdaptSteps = AsterFunc.AdaptThermal(resther,timestp,Loading1,Thermat,Thermod,Parameters.Theta,Parameters.Solver,Storing = Storing, MaxIter=MaxIter,EndIndex = FinIx)

### Laser Off
if fintime > LPend:
	FinIx = TotStep
	newSteps = AsterFunc.AdaptThermal(resther,timestp,Loading2,Thermat,Thermod,Parameters.Theta,Parameters.Solver,Storing = Storing, MaxIter=MaxIter,EndIndex = FinIx)
	AdaptSteps = np.concatenate((AdaptSteps,newSteps[1:]))

# Save list of timesteps and results for the study
np.savetxt('./REPE_OUT/TimeSteps.dat', AdaptSteps, fmt = '%.6f', delimiter = '   ')
DEFI_FICHIER(FICHIER='./REPE_OUT/{}.rmed'.format(Parameters.ResName), UNITE=81)
IMPR_RESU(RESU=_F(RESULTAT=resther), UNITE=81)

FIN()
