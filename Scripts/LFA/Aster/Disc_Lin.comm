import sys
sys.dont_write_bytecode=True
import os
import numpy as np
import time as tm
from Utilitai import partition

import AsterFunc
import Parameters
import PathVL

def GaussProfile(x,y,sigma):
	z = (1/(2*pi*sigma**2))*np.exp(-(x**2+y**2)/(2*sigma**2))
	return z

def LinMaterial(Temperature, data):
	# This function allows us to use a Linear on NonLinear material for the simulation
	if len(data) == 4 and data[1]==data[3]: return data[1]
	else : return np.interp(Temperature, data[::2], data[1::2])

DEBUT(PAR_LOT = 'NON',LANG='EN')
#from scipy import special
#Vlaser = special.erf(np.sqrt(0.0075*10**3)/(np.sqrt(2)*sigma*10**3))
#Vdisk = special.erf(np.sqrt(Parameters.Radius*10**3)/(np.sqrt(2)*sigma*10**3))
#E_exp = Parameters.Energy*Vdisk/Vlaser # Energy imparted in to system

##### Read in the mesh and define the model #####

mesh = LIRE_MAILLAGE(FORMAT='MED',UNITE=20)
mesht = partition.MAIL_PY()
mesht.FromAster('mesh')
	
Thermod = AFFE_MODELE(AFFE=_F(MODELISATION=(Parameters.Model, ),
	                      PHENOMENE='THERMIQUE',
	                      TOUT='OUI'),
	             	      MAILLAGE=mesh)

##### Define functions for NL material properties and assign materials to parts #####
DictMat = AsterFunc.MaterialProps(PathVL.MATERIAL_DIR, Parameters.Materials.values())
MatTemperature=20 # Material Properties at this temp if NL Material used
# Top Disk
TopLambda = LinMaterial(MatTemperature, DictMat[Parameters.Materials['Top']]['Lambda'])
TopRhoCp = LinMaterial(MatTemperature, DictMat[Parameters.Materials['Top']]['RhoCp'])
TopMat = DEFI_MATERIAU(THER=_F(LAMBDA = TopLambda, RHO_CP = TopRhoCp))
# Bottom Disk
BotLambda = LinMaterial(MatTemperature, DictMat[Parameters.Materials['Bottom']]['Lambda'])
BotRhoCp = LinMaterial(MatTemperature, DictMat[Parameters.Materials['Bottom']]['RhoCp'])
BotMat = DEFI_MATERIAU(THER=_F(LAMBDA = BotLambda, RHO_CP = BotRhoCp))

Thermat = AFFE_MATERIAU(AFFE=(_F(MATER=TopMat, GROUP_MA='Top'),_F(MATER=BotMat, GROUP_MA='Bottom')),
	                MAILLAGE=mesh)

##### Create list of time steps #####
start = 0
timelist, savelist = [], []
for i, tup in enumerate(Parameters.dt):
	if len(tup) == 3: dt, Nstep, save = tup
	else :dt, Nstep, save = tup[0],tup[1], 1

	fintime = start + dt*Nstep
	timesteps = np.linspace(start,fintime,Nstep+1).tolist()

	if i == 0: 
		timelist.append(timesteps)
		savelist.append(timesteps[::save])
	else: 
		timelist.append(timesteps[1:])
		savelist.append(timesteps[save::save])

	start = fintime

timearr = timearrOrig = np.concatenate(timelist)
savearr = np.concatenate(savelist)

##### Create BCs #####

## Laser Temporal Profile
Lsrdat = np.fromfile('{}/Laser/{}.dat'.format(PathVL.SIM_SCRIPTS, Parameters.LaserT),dtype=float,count=-1,sep=" ")
LsrProf = DEFI_FONCTION(NOM_PARA='INST',
		       PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
		       VALE=Lsrdat)
Lsrdat = Lsrdat.reshape(int(len(Lsrdat)/2),2)
xlaser, flaser = Lsrdat[:,0], Lsrdat[:,1]
LaserArea = np.trapz(flaser, x=xlaser)

## Laser Spatial Profile
TopArea,TopNodes = AsterFunc.BCinfo(mesh,Group = 'Top_Face')[0:2]

if Parameters.LaserS == 'Uniform':
	Fn = Parameters.Energy/(sum(TopArea)*LaserArea)
	FluxProf = DEFI_CONSTANTE(VALE=Fn)
elif Parameters.LaserS in ('Gauss','gauss'):
	sigma = 0.005/(-2*np.log(1-0.1))**0.5 ### This value of sigma ensures a 10% reduction 5mm away from centre
	Coors = mesht.cn[TopNodes]
	x, y  = Coors[:,0], Coors[:,1]
	Gauss = GaussProfile(x,y,sigma)
	SumLoad = np.dot(TopArea, Gauss)
	Fn = Parameters.Energy/(SumLoad*LaserArea) ### Value Fn scales Gaussian profileto ensure correct energy input

	FluxProf = FORMULE(VALE='Fn*GaussProfile(X,Y,sigma)',
		       NOM_PARA=('X', 'Y'),sigma=sigma,Fn=Fn,GaussProfile=GaussProfile)

LaserOn = AFFE_CHAR_THER_F(FLUX_REP=_F(FLUN=FluxProf, GROUP_MA='Top_Face'),
			   MODELE=Thermod)

## Heat Transfer BC
BotHTC = DEFI_CONSTANTE(VALE=Parameters.BottomHTC)
TopHTC = DEFI_CONSTANTE(VALE=Parameters.TopHTC)
T_ext = DEFI_CONSTANTE(VALE=Parameters.ExtTemp)

HT = AFFE_CHAR_THER_F(ECHANGE=(_F(COEF_H=BotHTC, TEMP_EXT=T_ext, GROUP_MA='Bottom_Ext'), 
			       _F(COEF_H=TopHTC, TEMP_EXT=T_ext, GROUP_MA='Top_Ext')),
		      MODELE=Thermod)

## Loads
Loading1 = (_F(CHARGE=LaserOn, FONC_MULT=LsrProf),_F(CHARGE=HT))
Loading2 = (_F(CHARGE=HT))

### No results to import so we start with the initial temperature
if Parameters.ImportRes not in ('Yes','Y','yes','y'):
	StartTime = 0
	field = CREA_CHAMP(AFFE=_F(NOM_CMP='TEMP',TOUT='OUI',VALE=Parameters.InitTemp),MAILLAGE=mesh,OPERATION='AFFE',TYPE_CHAM='NOEU_TEMP_R')
	resther = CREA_RESU(AFFE=_F(CHAM_GD=field,INST=0.0),NOM_CHAM='TEMP',OPERATION='AFFE',TYPE_RESU='EVOL_THER')

### Import starting temperature profile from results
else:	
	DEFI_FICHIER(FICHIER=PathVL.RESULTS_DIR + '/ResTher.rmed', UNITE=40)		
	resther = LIRE_RESU(FORMAT='MED',
			    FORMAT_MED=_F(NOM_CHAM='TEMP',
			    NOM_RESU='resther'),
			    MAILLAGE=mesh,
			    TOUT_ORDRE='OUI',
			    TYPE_RESU='EVOL_THER',
			    UNITE=40)
	StartTime = (resther.LIST_VARI_ACCES()['INST'])[-1]
	NewIndex = np.argmin(abs(timearr - StartTime))

	if os.path.isfile(PathVL.DATA_DIR + '/TimeSteps.dat'):
		PrevTime = np.fromfile(PathVL.DATA_DIR + '/TimeSteps.dat',dtype=float,count=-1,sep=' ')
		ImportIndex = np.argmin(abs(PrevTime - StartTime))
		timearr = np.concatenate((PrevTime[0:ImportIndex+1],timearr[NewIndex+1:]))
		savearr=timearr
	else:
		ImportIndex = 0
		timearr = timearr[NewIndex:]

MaxIter = getattr(Parameters, 'MaxIter', 10)
LPend = getattr(Parameters, 'LaserEnd', xlaser[-1])
LPindex = np.argmin(abs(timearr - LPend))

timestp = DEFI_LIST_REEL(VALE=timearr)
Storing = DEFI_LIST_REEL(VALE=savearr)

### LaserOn
if  StartTime < LPend:
	resther = THER_LINEAIRE(reuse=resther,
				ARCHIVAGE=_F(LIST_INST=Storing),
				CHAM_MATER=Thermat,
				ETAT_INIT=_F(EVOL_THER=resther),
				EXCIT=Loading1,
				INCREMENT=_F(NUME_INST_FIN=LPindex, LIST_INST=timestp),
				MODELE=Thermod,
				PARM_THETA=Parameters.Theta,
				SOLVEUR=_F(METHODE=Parameters.Solver),
				RESULTAT=resther)

### Laser Off
if fintime > LPend:
	resther = THER_LINEAIRE(reuse=resther,
				ARCHIVAGE=_F(LIST_INST=Storing),
				CHAM_MATER=Thermat,
				ETAT_INIT=_F(EVOL_THER=resther),
				EXCIT=Loading2,
				INCREMENT=_F(LIST_INST=timestp),
				MODELE=Thermod,
				PARM_THETA=Parameters.Theta,
				SOLVEUR=_F(METHODE=Parameters.Solver),
				RESULTAT=resther)


# Save list of timesteps and results for the study
np.savetxt('./REPE_OUT/TimeSteps.dat', timearr, fmt = '%.6f', delimiter = '   ')
DEFI_FICHIER(FICHIER='./REPE_OUT/{}.rmed'.format(Parameters.ResName), UNITE=81)
IMPR_RESU(RESU=_F(RESULTAT=resther), UNITE=81)

FIN()
