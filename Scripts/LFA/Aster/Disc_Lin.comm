import sys
sys.dont_write_bytecode=True
import os
import numpy as np
import time as tm
from Utilitai import partition

import AsterFunc
import Parameters
import PathVL

def GaussProfile(x,y,sigma):
	z = (1/(2*pi*sigma**2))*np.exp(-(x**2+y**2)/(2*sigma**2))
	return z

def LinMaterial(Temperature, data):
	# This function allows us to use a Linear on NonLinear material for the simulation
	if len(data) == 4 and data[1]==data[3]: return data[1]
	else : return np.interp(Temperature, data[::2], data[1::2])

DEBUT(PAR_LOT = 'NON',LANG='EN')
#from scipy import special
#Vlaser = special.erf(np.sqrt(0.0075*10**3)/(np.sqrt(2)*sigma*10**3))
#Vdisk = special.erf(np.sqrt(Parameters.Radius*10**3)/(np.sqrt(2)*sigma*10**3))
#E_exp = Parameters.Energy*Vdisk/Vlaser # Energy imparted in to system

##### Read in the mesh and define the model #####

mesh = LIRE_MAILLAGE(FORMAT='MED',UNITE=20)
mesht = partition.MAIL_PY()
mesht.FromAster('mesh')

Thermod = AFFE_MODELE(AFFE=_F(MODELISATION=(Parameters.Model, ),
	                      PHENOMENE='THERMIQUE',
	                      TOUT='OUI'),
	             	      MAILLAGE=mesh)

##### Define functions for NL material properties and assign materials to parts #####
DictMat = AsterFunc.MaterialProps(PathVL.MATERIAL_DIR, Parameters.Materials.values())
MatTemperature=20 # Material Properties at this temp if NL Material used
# Top Disk
TopLambda = LinMaterial(MatTemperature, DictMat[Parameters.Materials['Top']]['Lambda'])
TopRhoCp = LinMaterial(MatTemperature, DictMat[Parameters.Materials['Top']]['RhoCp'])
TopMat = DEFI_MATERIAU(THER=_F(LAMBDA = TopLambda, RHO_CP = TopRhoCp))
# Bottom Disk
BotLambda = LinMaterial(MatTemperature, DictMat[Parameters.Materials['Bottom']]['Lambda'])
BotRhoCp = LinMaterial(MatTemperature, DictMat[Parameters.Materials['Bottom']]['RhoCp'])
BotMat = DEFI_MATERIAU(THER=_F(LAMBDA = BotLambda, RHO_CP = BotRhoCp))

Thermat = AFFE_MATERIAU(AFFE=(_F(MATER=TopMat, GROUP_MA='Top'),_F(MATER=BotMat, GROUP_MA='Bottom')),
	                MAILLAGE=mesh)

### Get timesteps and savesteps using dt provided in Parameters ###
timearr, savearr = AsterFunc.Timesteps(Parameters.dt)
Timestp = DEFI_LIST_REEL(VALE=timearr)
Savestp = DEFI_LIST_REEL(VALE=savearr)


##### Create BCs #####
## Laser Temporal Profile
Lsrdat = np.fromfile('{}/Laser/{}.dat'.format(PathVL.SIM_SCRIPTS, Parameters.LaserT),dtype=float,count=-1,sep=" ")
LsrProf = DEFI_FONCTION(NOM_PARA='INST',
		       PROL_DROITE='CONSTANT',
	               PROL_GAUCHE='CONSTANT',
		       VALE=Lsrdat)
Lsrdat = Lsrdat.reshape(int(len(Lsrdat)/2),2)
xlaser, flaser = Lsrdat[:,0], Lsrdat[:,1]
LaserArea = np.trapz(flaser, x=xlaser)

## Laser Spatial Profile
TopArea,TopNodes = AsterFunc.BCinfo(mesh,Group = 'Top_Face')[0:2]
if Parameters.LaserS == 'Uniform':
	Fn = Parameters.Energy/(sum(TopArea)*LaserArea)
	FluxProf = DEFI_CONSTANTE(VALE=Fn)
elif Parameters.LaserS in ('Gauss','gauss'):
	sigma = 0.005/(-2*np.log(1-0.1))**0.5 ### This value of sigma ensures a 10% reduction 5mm away from centre
	Coors = mesht.cn[TopNodes]
	x, y  = Coors[:,0], Coors[:,1]
	Gauss = GaussProfile(x,y,sigma)
	SumLoad = np.dot(TopArea, Gauss)
	Fn = Parameters.Energy/(SumLoad*LaserArea) ### Value Fn scales Gaussian profileto ensure correct energy input

	FluxProf = FORMULE(VALE='Fn*GaussProfile(X,Y,sigma)',
		       NOM_PARA=('X', 'Y'),sigma=sigma,Fn=Fn,GaussProfile=GaussProfile)

LaserOn = AFFE_CHAR_THER_F(FLUX_REP=_F(FLUN=FluxProf, GROUP_MA='Top_Face'),
			   MODELE=Thermod)

## Heat Transfer BC
BotHTC = DEFI_CONSTANTE(VALE=Parameters.BottomHTC)
TopHTC = DEFI_CONSTANTE(VALE=Parameters.TopHTC)
T_ext = DEFI_CONSTANTE(VALE=Parameters.ExtTemp)

HT = AFFE_CHAR_THER_F(ECHANGE=(_F(COEF_H=BotHTC, TEMP_EXT=T_ext, GROUP_MA='Bottom_Ext'),
			       _F(COEF_H=TopHTC, TEMP_EXT=T_ext, GROUP_MA='Top_Ext')),
		      MODELE=Thermod)

## Loads
Loading1 = (_F(CHARGE=LaserOn, FONC_MULT=LsrProf),_F(CHARGE=HT))
Loading2 = (_F(CHARGE=HT))

### Temperature distribution to start simulation
field = CREA_CHAMP(AFFE=_F(NOM_CMP='TEMP',TOUT='OUI',VALE=Parameters.InitTemp),MAILLAGE=mesh,OPERATION='AFFE',TYPE_CHAM='NOEU_TEMP_R')
resther = CREA_RESU(AFFE=_F(CHAM_GD=field,INST=0.0),NOM_CHAM='TEMP',OPERATION='AFFE',TYPE_RESU='EVOL_THER')
StartTime=0

## Start  thermal analysis ##
MaxIter = getattr(Parameters, 'MaxIter', 10)
LPend = getattr(Parameters, 'LaserEnd', xlaser[-1])
LPindex = np.argmin(np.abs(timearr - LPend))
Theta = getattr(Parameters,'Theta',0.5)
Solver = getattr(Parameters,'Solver', 'MUMPS')

### LaserOn
if  StartTime < LPend:
	resther = THER_LINEAIRE(reuse=resther,
				ARCHIVAGE=_F(LIST_INST=Savestp),
				CHAM_MATER=Thermat,
				ETAT_INIT=_F(EVOL_THER=resther),
				EXCIT=Loading1,
				INCREMENT=_F(NUME_INST_FIN=LPindex, LIST_INST=Timestp),
				MODELE=Thermod,
				PARM_THETA=Theta,
				SOLVEUR=_F(METHODE=Solver),
				RESULTAT=resther)

### Laser Off
if timearr[-1] > LPend:
	resther = THER_LINEAIRE(reuse=resther,
				ARCHIVAGE=_F(LIST_INST=Savestp),
				CHAM_MATER=Thermat,
				ETAT_INIT=_F(EVOL_THER=resther),
				EXCIT=Loading2,
				INCREMENT=_F(LIST_INST=Timestp),
				MODELE=Thermod,
				PARM_THETA=Theta,
				SOLVEUR=_F(METHODE=Solver),
				RESULTAT=resther)


# Save list of timesteps and results for the study
np.savetxt('./REPE_OUT/TimeSteps.dat', timearr, fmt = '%.6f', delimiter = '   ')
DEFI_FICHIER(FICHIER='./REPE_OUT/Thermal.rmed', UNITE=81)
IMPR_RESU(RESU=_F(RESULTAT=resther), UNITE=81)

FIN()
